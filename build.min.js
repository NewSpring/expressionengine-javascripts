/*!
 * EventEmitter v4.2.11 - git.io/ee
 * Unlicense - http://unlicense.org/
 * Oliver Caldwell - http://oli.me.uk/
 * @preserve
 */
(function () {
    "use strict";

    function t() {}

    function i(t, n) {
        for (var e = t.length; e--;) if (t[e].listener === n) return e;
        return -1
    }

    function n(e) {
        return function () {
            return this[e].apply(this, arguments)
        }
    }
    var e = t.prototype,
        r = this,
        s = r.EventEmitter;
    e.getListeners = function (n) {
        var r, e, t = this._getEvents();
        if (n instanceof RegExp) {
            r = {};
            for (e in t) t.hasOwnProperty(e) && n.test(e) && (r[e] = t[e])
        } else r = t[n] || (t[n] = []);
        return r
    }, e.flattenListeners = function (t) {
        var e, n = [];
        for (e = 0; e < t.length; e += 1) n.push(t[e].listener);
        return n
    }, e.getListenersAsObject = function (n) {
        var e, t = this.getListeners(n);
        return t instanceof Array && (e = {}, e[n] = t), e || t
    }, e.addListener = function (r, e) {
        var t, n = this.getListenersAsObject(r),
            s = "object" == typeof e;
        for (t in n) n.hasOwnProperty(t) && -1 === i(n[t], e) && n[t].push(s ? e : {
            listener: e,
            once: !1
        });
        return this
    }, e.on = n("addListener"), e.addOnceListener = function (e, t) {
        return this.addListener(e, {
            listener: t,
            once: !0
        })
    }, e.once = n("addOnceListener"), e.defineEvent = function (e) {
        return this.getListeners(e), this
    }, e.defineEvents = function (t) {
        for (var e = 0; e < t.length; e += 1) this.defineEvent(t[e]);
        return this
    }, e.removeListener = function (r, s) {
        var n, e, t = this.getListenersAsObject(r);
        for (e in t) t.hasOwnProperty(e) && (n = i(t[e], s), -1 !== n && t[e].splice(n, 1));
        return this
    }, e.off = n("removeListener"), e.addListeners = function (e, t) {
        return this.manipulateListeners(!1, e, t)
    }, e.removeListeners = function (e, t) {
        return this.manipulateListeners(!0, e, t)
    }, e.manipulateListeners = function (r, t, i) {
        var e, n, s = r ? this.removeListener : this.addListener,
            o = r ? this.removeListeners : this.addListeners;
        if ("object" != typeof t || t instanceof RegExp) for (e = i.length; e--;) s.call(this, t, i[e]);
        else for (e in t) t.hasOwnProperty(e) && (n = t[e]) && ("function" == typeof n ? s.call(this, e, n) : o.call(this, e, n));
        return this
    }, e.removeEvent = function (e) {
        var t, r = typeof e,
            n = this._getEvents();
        if ("string" === r) delete n[e];
        else if (e instanceof RegExp) for (t in n) n.hasOwnProperty(t) && e.test(t) && delete n[t];
        else delete this._events;
        return this
    }, e.removeAllListeners = n("removeEvent"), e.emitEvent = function (r, o) {
        var e, i, t, s, n = this.getListenersAsObject(r);
        for (t in n) if (n.hasOwnProperty(t)) for (i = n[t].length; i--;) e = n[t][i], e.once === !0 && this.removeListener(r, e.listener), s = e.listener.apply(this, o || []), s === this._getOnceReturnValue() && this.removeListener(r, e.listener);
        return this
    }, e.trigger = n("emitEvent"), e.emit = function (e) {
        var t = Array.prototype.slice.call(arguments, 1);
        return this.emitEvent(e, t)
    }, e.setOnceReturnValue = function (e) {
        return this._onceReturnValue = e, this
    }, e._getOnceReturnValue = function () {
        return this.hasOwnProperty("_onceReturnValue") ? this._onceReturnValue : !0
    }, e._getEvents = function () {
        return this._events || (this._events = {})
    }, t.noConflict = function () {
        return r.EventEmitter = s, t
    }, "function" == typeof define && define.amd ? define(function () {
        return t
    }) : "object" == typeof module && module.exports ? module.exports = t : r.EventEmitter = t
}).call(this);




(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('smoothScroll', factory(root));
    } else if (typeof exports === 'object') {
        module.smoothScroll = factory(root);
    } else {
        root.smoothScroll = factory(root);
    }
})(this, function (root) {

    'use strict';

    //
    // Variables
    //
    var exports = {}; // Object for public APIs
    var supports = !! document.querySelector && !! root.addEventListener; // Feature test
    var settings;

    // Default settings
    var defaults = {
        speed: 500,
        easing: 'easeInOutCubic',
        offset: 0,
        updateURL: true,
        callbackBefore: function () {},
        callbackAfter: function () {}
    };


    //
    // Methods
    //
    /**
     * A simple forEach() implementation for Arrays, Objects and NodeLists
     * @private
     * @param {Array|Object|NodeList} collection Collection of items to iterate
     * @param {Function} callback Callback function for each iteration
     * @param {Array|Object|NodeList} scope Object/NodeList/Array that forEach is iterating over (aka this)
     */
    var forEach = function (collection, callback, scope) {
        if (Object.prototype.toString.call(collection) === '[object Object]') {
            for (var prop in collection) {
                if (Object.prototype.hasOwnProperty.call(collection, prop)) {
                    callback.call(scope, collection[prop], prop, collection);
                }
            }
        } else {
            for (var i = 0, len = collection.length; i < len; i++) {
                callback.call(scope, collection[i], i, collection);
            }
        }
    };

    /**
     * Merge defaults with user options
     * @private
     * @param {Object} defaults Default settings
     * @param {Object} options User options
     * @returns {Object} Merged values of defaults and options
     */
    var extend = function (defaults, options) {
        var extended = {};
        forEach(defaults, function (value, prop) {
            extended[prop] = defaults[prop];
        });
        forEach(options, function (value, prop) {
            extended[prop] = options[prop];
        });
        return extended;
    };

    /**
     * Calculate the easing pattern
     * @private
     * @param {String} type Easing pattern
     * @param {Number} time Time animation should take to complete
     * @returns {Number}
     */
    var easingPattern = function (type, time) {
        var pattern;
        if (type === 'easeInQuad') pattern = time * time; // accelerating from zero velocity
        if (type === 'easeOutQuad') pattern = time * (2 - time); // decelerating to zero velocity
        if (type === 'easeInOutQuad') pattern = time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time; // acceleration until halfway, then deceleration
        if (type === 'easeInCubic') pattern = time * time * time; // accelerating from zero velocity
        if (type === 'easeOutCubic') pattern = (--time) * time * time + 1; // decelerating to zero velocity
        if (type === 'easeInOutCubic') pattern = time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1; // acceleration until halfway, then deceleration
        if (type === 'easeInQuart') pattern = time * time * time * time; // accelerating from zero velocity
        if (type === 'easeOutQuart') pattern = 1 - (--time) * time * time * time; // decelerating to zero velocity
        if (type === 'easeInOutQuart') pattern = time < 0.5 ? 8 * time * time * time * time : 1 - 8 * (--time) * time * time * time; // acceleration until halfway, then deceleration
        if (type === 'easeInQuint') pattern = time * time * time * time * time; // accelerating from zero velocity
        if (type === 'easeOutQuint') pattern = 1 + (--time) * time * time * time * time; // decelerating to zero velocity
        if (type === 'easeInOutQuint') pattern = time < 0.5 ? 16 * time * time * time * time * time : 1 + 16 * (--time) * time * time * time * time; // acceleration until halfway, then deceleration
        return pattern || time; // no easing, no acceleration
    };

    /**
     * Calculate how far to scroll
     * @private
     * @param {Element} anchor The anchor element to scroll to
     * @param {Number} headerHeight Height of a fixed header, if any
     * @param {Number} offset Number of pixels by which to offset scroll
     * @returns {Number}
     */
    var getEndLocation = function (anchor, headerHeight, offset) {
        var location = 0;
        if (anchor.offsetParent) {
            do {
                location += anchor.offsetTop;
                anchor = anchor.offsetParent;
            } while (anchor);
        }
        location = location - headerHeight - offset;
        return location >= 0 ? location : 0;
    };

    /**
     * Determine the document's height
     * @private
     * @returns {Number}
     */
    var getDocumentHeight = function () {
        return Math.max(
        document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight);
    };

    /**
     * Convert data-options attribute into an object of key/value pairs
     * @private
     * @param {String} options Link-specific options as a data attribute string
     * @returns {Object}
     */
    var getDataOptions = function (options) {
        return !options || !(typeof JSON === 'object' && typeof JSON.parse === 'function') ? {} : JSON.parse(options);
    };

    /**
     * Update the URL
     * @private
     * @param {Element} anchor The element to scroll to
     * @param {Boolean} url Whether or not to update the URL history
     */
    var updateUrl = function (anchor, url) {
        if (history.pushState && (url || url === 'true')) {
            history.pushState({
                pos: anchor.id
            }, '', window.location.pathname + anchor);
        }
    };

    /**
     * Start/stop the scrolling animation
     * @public
     * @param {Element} toggle The element that toggled the scroll event
     * @param {Element} anchor The element to scroll to
     * @param {Object} settings
     * @param {Event} event
     */
    exports.animateScroll = function (toggle, anchor, options, event) {

        // Options and overrides
        var settings = extend(settings || defaults, options || {}); // Merge user options with defaults
        var overrides = getDataOptions(toggle ? toggle.getAttribute('data-options') : null);
        settings = extend(settings, overrides);

        // Selectors and variables
        var fixedHeader = document.querySelector('[data-scroll-header]'); // Get the fixed header
        var headerHeight = fixedHeader === null ? 0 : (fixedHeader.offsetHeight + fixedHeader.offsetTop); // Get the height of a fixed header if one exists
        var startLocation = root.pageYOffset; // Current location on the page
        var endLocation = getEndLocation(document.querySelector(anchor), headerHeight, parseInt(settings.offset, 10)); // Scroll to location
        var animationInterval; // interval timer
        var distance = endLocation - startLocation; // distance to travel
        var documentHeight = getDocumentHeight();
        var timeLapsed = 0;
        var percentage, position;

        // Prevent default click event
        if (toggle && toggle.tagName.toLowerCase() === 'a' && event) {
            event.preventDefault();
        }

        // Update URL
        updateUrl(anchor, settings.updateURL);

        /**
         * Stop the scroll animation when it reaches its target (or the bottom/top of page)
         * @private
         * @param {Number} position Current position on the page
         * @param {Number} endLocation Scroll to location
         * @param {Number} animationInterval How much to scroll on this loop
         */
        var stopAnimateScroll = function (position, endLocation, animationInterval) {
            var currentLocation = root.pageYOffset;
            if (position == endLocation || currentLocation == endLocation || ((root.innerHeight + currentLocation) >= documentHeight)) {
                clearInterval(animationInterval);
                settings.callbackAfter(toggle, anchor); // Run callbacks after animation complete
            }
        };

        /**
         * Loop scrolling animation
         * @private
         */
        var loopAnimateScroll = function () {
            timeLapsed += 16;
            percentage = (timeLapsed / parseInt(settings.speed, 10));
            percentage = (percentage > 1) ? 1 : percentage;
            position = startLocation + (distance * easingPattern(settings.easing, percentage));
            root.scrollTo(0, Math.floor(position));
            stopAnimateScroll(position, endLocation, animationInterval);
        };

        /**
         * Set interval timer
         * @private
         */
        var startAnimateScroll = function () {
            settings.callbackBefore(toggle, anchor); // Run callbacks before animating scroll
            animationInterval = setInterval(loopAnimateScroll, 16);
        };

        /**
         * Reset position to fix weird iOS bug
         * @link https://github.com/cferdinandi/smooth-scroll/issues/45
         */
        if (root.pageYOffset === 0) {
            root.scrollTo(0, 0);
        }

        // Start scrolling animation
        startAnimateScroll();

    };

    /**
     * Initialize Smooth Scroll
     * @public
     * @param {Object} options User settings
     */
    exports.init = function (options) {

        // feature test
        if (!supports) return;

        // Selectors and variables
        settings = extend(defaults, options || {}); // Merge user options with defaults
        var toggles = document.querySelectorAll('[data-scroll]'); // Get smooth scroll toggles
        // When a toggle is clicked, run the click handler
        forEach(toggles, function (toggle) {
            toggle.addEventListener('click', exports.animateScroll.bind(null, toggle, toggle.hash, settings), false);
        });

    };


    //
    // Public APIs
    //
    return exports;

});


/*! echo.js v1.6.0 | (c) 2014 @toddmotto | https://github.com/toddmotto/echo */
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define(factory);
    } else if (typeof exports === 'object') {
        module.exports = factory;
    } else {
        root.echo = factory(root);
    }
})(this, function (root) {

    'use strict';

    var echo = {};

    var callback = function () {};

    var offset, poll, throttle, unload;

    var inView = function (element, view) {
        var box = element.getBoundingClientRect();
        return (box.right >= view.l && box.bottom >= view.t && box.left <= view.r && box.top <= view.b);
    };

    var debounce = function () {
        clearTimeout(poll);
        poll = setTimeout(echo.render, throttle);
    };

    var addClass, removeClass, hasClass;

    hasClass = function (elem, className) {
        return new RegExp(" " + className + " ").test(" " + elem.className + " ");
    };

    addClass = function (elem, className) {
        if (!hasClass(elem, className)) {
            return elem.className += " " + className;
        }
    };

    removeClass = function (elem, className) {
        var newClass;
        newClass = " " + elem.className.replace(/[\t\r\n]/g, " ") + " ";
        if (hasClass(elem, className)) {
            while (newClass.indexOf(" " + className + " ") >= 0) {
                newClass = newClass.replace(" " + className + " ", " ");
            }
            return elem.className = newClass.replace(/^\s+|\s+$/g, "");
        }
    };

    echo.init = function (opts) {
        opts = opts || {};
        var offsetAll = opts.offset || 0;
        var offsetVertical = opts.offsetVertical || offsetAll;
        var offsetHorizontal = opts.offsetHorizontal || offsetAll;
        var optionToInt = function (opt, fallback) {
            return parseInt(opt || fallback, 10);
        };
        offset = {
            t: optionToInt(opts.offsetTop, offsetVertical),
            b: optionToInt(opts.offsetBottom, offsetVertical),
            l: optionToInt(opts.offsetLeft, offsetHorizontal),
            r: optionToInt(opts.offsetRight, offsetHorizontal)
        };
        throttle = optionToInt(opts.throttle, 250);
        unload = !! opts.unload;
        callback = opts.callback || callback;
        echo.render();
        if (document.addEventListener) {
            root.addEventListener('scroll', debounce, false);
            root.addEventListener('load', debounce, false);
        } else {
            root.attachEvent('onscroll', debounce);
            root.attachEvent('onload', debounce);
        }
    };

    echo.render = function () {
        var nodes = document.querySelectorAll('[data-lazy-load]');
        var length = nodes.length;
        var src, elem;
        var view = {
            l: 0 - offset.l,
            t: 0 - offset.t,
            b: (root.innerHeight || document.documentElement.clientHeight) + offset.b,
            r: (root.innerWidth || document.documentElement.clientWidth) + offset.r
        };
        for (var i = 0; i < length; i++) {
            elem = nodes[i];
            addClass(elem, 'lazy--pre')
            if (inView(elem, view)) {
                if (unload) {
                    elem.setAttribute('data-lazy-load-placeholder', elem.src);
                }
                if (elem.tagName != 'IMG') {
                    var img;
                    img = document.createElement('IMG')
                    img.src = elem.getAttribute('data-lazy-load')

                    var applyBgImage = function (e) {
                        var ele = e.target.stashedEle

                        ele.style.backgroundImage = 'url( ' + ele.getAttribute('data-lazy-load') + ')'
                        addClass(ele, 'lazy--post')
                        removeClass(ele, 'lazy--pre')

                        // if (!unload) {
                        //   ele.removeAttribute('data-lazy-load');
                        // }
                        callback(ele, 'load');

                    }
                    img.stashedEle = elem
                    img.addEventListener('load', applyBgImage, false)

                } else {
                    var img;
                    img = document.createElement('IMG')
                    img.src = ele.getAttribute('data-lazy-load')

                    var applyImage = function (e) {
                        var ele = e.target.stashedEle
                        ele.src = ele.getAttribute('data-lazy-load');
                        addClass(ele, 'lazy--post')
                        removeClass(ele, 'lazy--pre')

                        // if (!unload) {
                        //   ele.removeAttribute('data-lazy-load');
                        // }
                        callback(ele, 'load');

                    }
                    img.stashedEle = elem
                    img.addEventListener('load', applyImage, false)

                }


            } else if (unload && !! (src = elem.getAttribute('data-lazy-load-placeholder'))) {

                if (elem.tagName != 'IMG') {
                    elem.style.backgroundImage = 'url( ' + src + ')'
                } else {
                    elem.src = src;
                }
                elem.removeAttribute('data-lazy-load-placeholder');
                callback(elem, 'unload');
            }
        }
        if (!length) {
            echo.detach();
        }
    };

    echo.detach = function () {
        if (document.removeEventListener) {
            root.removeEventListener('scroll', debounce);
        } else {
            root.detachEvent('onscroll', debounce);
        }
        clearTimeout(poll);
    };

    return echo;

});


/*!

 handlebars v1.3.0

Copyright (C) 2011 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license
*/
/* exported Handlebars */
var Handlebars = (function () {
    // handlebars/safe-string.js
    var __module3__ = (function () {
        "use strict";
        var __exports__;
        // Build out our basic SafeString type

        function SafeString(string) {
            this.string = string;
        }

        SafeString.prototype.toString = function () {
            return "" + this.string;
        };

        __exports__ = SafeString;
        return __exports__;
    })();

    // handlebars/utils.js
    var __module2__ = (function (__dependency1__) {
        "use strict";
        var __exports__ = {}; /*jshint -W004 */
        var SafeString = __dependency1__;

        var escape = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#x27;",
            "`": "&#x60;"
        };

        var badChars = /[&<>"'`]/g;
        var possible = /[&<>"'`]/;

        function escapeChar(chr) {
            return escape[chr] || "&amp;";
        }

        function extend(obj, value) {
            for (var key in value) {
                if (Object.prototype.hasOwnProperty.call(value, key)) {
                    obj[key] = value[key];
                }
            }
        }

        __exports__.extend = extend;
        var toString = Object.prototype.toString;
        __exports__.toString = toString;
        // Sourced from lodash
        // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
        var isFunction = function (value) {
            return typeof value === 'function';
        };
        // fallback for older versions of Chrome and Safari
        if (isFunction(/x/)) {
            isFunction = function (value) {
                return typeof value === 'function' && toString.call(value) === '[object Function]';
            };
        }
        var isFunction;
        __exports__.isFunction = isFunction;
        var isArray = Array.isArray ||
        function (value) {
            return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;
        };
        __exports__.isArray = isArray;

        function escapeExpression(string) {
            // don't escape SafeStrings, since they're already safe
            if (string instanceof SafeString) {
                return string.toString();
            } else if (!string && string !== 0) {
                return "";
            }

            // Force a string conversion as this will be done by the append regardless and
            // the regex test will do this transparently behind the scenes, causing issues if
            // an object's to string has escaped characters in it.
            string = "" + string;

            if (!possible.test(string)) {
                return string;
            }
            return string.replace(badChars, escapeChar);
        }

        __exports__.escapeExpression = escapeExpression;

        function isEmpty(value) {
            if (!value && value !== 0) {
                return true;
            } else if (isArray(value) && value.length === 0) {
                return true;
            } else {
                return false;
            }
        }

        __exports__.isEmpty = isEmpty;
        return __exports__;
    })(__module3__);

    // handlebars/exception.js
    var __module4__ = (function () {
        "use strict";
        var __exports__;

        var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

        function Exception(message, node) {
            var line;
            if (node && node.firstLine) {
                line = node.firstLine;

                message += ' - ' + line + ':' + node.firstColumn;
            }

            var tmp = Error.prototype.constructor.call(this, message);

            // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
            for (var idx = 0; idx < errorProps.length; idx++) {
                this[errorProps[idx]] = tmp[errorProps[idx]];
            }

            if (line) {
                this.lineNumber = line;
                this.column = node.firstColumn;
            }
        }

        Exception.prototype = new Error();

        __exports__ = Exception;
        return __exports__;
    })();

    // handlebars/base.js
    var __module1__ = (function (__dependency1__, __dependency2__) {
        "use strict";
        var __exports__ = {};
        var Utils = __dependency1__;
        var Exception = __dependency2__;

        var VERSION = "1.3.0";
        __exports__.VERSION = VERSION;
        var COMPILER_REVISION = 4;
        __exports__.COMPILER_REVISION = COMPILER_REVISION;
        var REVISION_CHANGES = {
            1: '<= 1.0.rc.2',
            // 1.0.rc.2 is actually rev2 but doesn't report it
            2: '== 1.0.0-rc.3',
            3: '== 1.0.0-rc.4',
            4: '>= 1.0.0'
        };
        __exports__.REVISION_CHANGES = REVISION_CHANGES;
        var isArray = Utils.isArray,
            isFunction = Utils.isFunction,
            toString = Utils.toString,
            objectType = '[object Object]';

        function HandlebarsEnvironment(helpers, partials) {
            this.helpers = helpers || {};
            this.partials = partials || {};

            registerDefaultHelpers(this);
        }

        __exports__.HandlebarsEnvironment = HandlebarsEnvironment;
        HandlebarsEnvironment.prototype = {
            constructor: HandlebarsEnvironment,

            logger: logger,
            log: log,

            registerHelper: function (name, fn, inverse) {
                if (toString.call(name) === objectType) {
                    if (inverse || fn) {
                        throw new Exception('Arg not supported with multiple helpers');
                    }
                    Utils.extend(this.helpers, name);
                } else {
                    if (inverse) {
                        fn.not = inverse;
                    }
                    this.helpers[name] = fn;
                }
            },

            registerPartial: function (name, str) {
                if (toString.call(name) === objectType) {
                    Utils.extend(this.partials, name);
                } else {
                    this.partials[name] = str;
                }
            }
        };

        function registerDefaultHelpers(instance) {
            instance.registerHelper('helperMissing', function (arg) {
                if (arguments.length === 2) {
                    return undefined;
                } else {
                    throw new Exception("Missing helper: '" + arg + "'");
                }
            });

            instance.registerHelper('blockHelperMissing', function (context, options) {
                var inverse = options.inverse ||
                function () {},
                    fn = options.fn;

                if (isFunction(context)) {
                    context = context.call(this);
                }

                if (context === true) {
                    return fn(this);
                } else if (context === false || context == null) {
                    return inverse(this);
                } else if (isArray(context)) {
                    if (context.length > 0) {
                        return instance.helpers.each(context, options);
                    } else {
                        return inverse(this);
                    }
                } else {
                    return fn(context);
                }
            });

            instance.registerHelper('each', function (context, options) {
                var fn = options.fn,
                    inverse = options.inverse;
                var i = 0,
                    ret = "",
                    data;

                if (isFunction(context)) {
                    context = context.call(this);
                }

                if (options.data) {
                    data = createFrame(options.data);
                }

                if (context && typeof context === 'object') {
                    if (isArray(context)) {
                        for (var j = context.length; i < j; i++) {
                            if (data) {
                                data.index = i;
                                data.first = (i === 0);
                                data.last = (i === (context.length - 1));
                            }
                            ret = ret + fn(context[i], {
                                data: data
                            });
                        }
                    } else {
                        for (var key in context) {
                            if (context.hasOwnProperty(key)) {
                                if (data) {
                                    data.key = key;
                                    data.index = i;
                                    data.first = (i === 0);
                                }
                                ret = ret + fn(context[key], {
                                    data: data
                                });
                                i++;
                            }
                        }
                    }
                }

                if (i === 0) {
                    ret = inverse(this);
                }

                return ret;
            });

            instance.registerHelper('if', function (conditional, options) {
                if (isFunction(conditional)) {
                    conditional = conditional.call(this);
                }

                // Default behavior is to render the positive path if the value is truthy and not empty.
                // The `includeZero` option may be set to treat the condtional as purely not empty based on the
                // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
                if ((!options.hash.includeZero && !conditional) || Utils.isEmpty(conditional)) {
                    return options.inverse(this);
                } else {
                    return options.fn(this);
                }
            });

            instance.registerHelper('unless', function (conditional, options) {
                return instance.helpers['if'].call(this, conditional, {
                    fn: options.inverse,
                    inverse: options.fn,
                    hash: options.hash
                });
            });

            instance.registerHelper('with', function (context, options) {
                if (isFunction(context)) {
                    context = context.call(this);
                }

                if (!Utils.isEmpty(context)) return options.fn(context);
            });

            instance.registerHelper('log', function (context, options) {
                var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
                instance.log(level, context);
            });
        }

        var logger = {
            methodMap: {
                0: 'debug',
                1: 'info',
                2: 'warn',
                3: 'error'
            },

            // State enum
            DEBUG: 0,
            INFO: 1,
            WARN: 2,
            ERROR: 3,
            level: 3,

            // can be overridden in the host environment
            log: function (level, obj) {
                if (logger.level <= level) {
                    var method = logger.methodMap[level];
                    if (typeof console !== 'undefined' && console[method]) {
                        console[method].call(console, obj);
                    }
                }
            }
        };
        __exports__.logger = logger;

        function log(level, obj) {
            logger.log(level, obj);
        }

        __exports__.log = log;
        var createFrame = function (object) {
            var obj = {};
            Utils.extend(obj, object);
            return obj;
        };
        __exports__.createFrame = createFrame;
        return __exports__;
    })(__module2__, __module4__);

    // handlebars/runtime.js
    var __module5__ = (function (__dependency1__, __dependency2__, __dependency3__) {
        "use strict";
        var __exports__ = {};
        var Utils = __dependency1__;
        var Exception = __dependency2__;
        var COMPILER_REVISION = __dependency3__.COMPILER_REVISION;
        var REVISION_CHANGES = __dependency3__.REVISION_CHANGES;

        function checkRevision(compilerInfo) {
            var compilerRevision = compilerInfo && compilerInfo[0] || 1,
                currentRevision = COMPILER_REVISION;

            if (compilerRevision !== currentRevision) {
                if (compilerRevision < currentRevision) {
                    var runtimeVersions = REVISION_CHANGES[currentRevision],
                        compilerVersions = REVISION_CHANGES[compilerRevision];
                    throw new Exception("Template was precompiled with an older version of Handlebars than the current runtime. " + "Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ").");
                } else {
                    // Use the embedded version info since the runtime doesn't know about this revision yet
                    throw new Exception("Template was precompiled with a newer version of Handlebars than the current runtime. " + "Please update your runtime to a newer version (" + compilerInfo[1] + ").");
                }
            }
        }

        __exports__.checkRevision = checkRevision; // TODO: Remove this line and break up compilePartial

        function template(templateSpec, env) {
            if (!env) {
                throw new Exception("No environment passed to template");
            }

            // Note: Using env.VM references rather than local var references throughout this section to allow
            // for external users to override these as psuedo-supported APIs.
            var invokePartialWrapper = function (partial, name, context, helpers, partials, data) {
                var result = env.VM.invokePartial.apply(this, arguments);
                if (result != null) {
                    return result;
                }

                if (env.compile) {
                    var options = {
                        helpers: helpers,
                        partials: partials,
                        data: data
                    };
                    partials[name] = env.compile(partial, {
                        data: data !== undefined
                    }, env);
                    return partials[name](context, options);
                } else {
                    throw new Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
                }
            };

            // Just add water
            var container = {
                escapeExpression: Utils.escapeExpression,
                invokePartial: invokePartialWrapper,
                programs: [],
                program: function (i, fn, data) {
                    var programWrapper = this.programs[i];
                    if (data) {
                        programWrapper = program(i, fn, data);
                    } else if (!programWrapper) {
                        programWrapper = this.programs[i] = program(i, fn);
                    }
                    return programWrapper;
                },
                merge: function (param, common) {
                    var ret = param || common;

                    if (param && common && (param !== common)) {
                        ret = {};
                        Utils.extend(ret, common);
                        Utils.extend(ret, param);
                    }
                    return ret;
                },
                programWithDepth: env.VM.programWithDepth,
                noop: env.VM.noop,
                compilerInfo: null
            };

            return function (context, options) {
                options = options || {};
                var namespace = options.partial ? options : env,
                    helpers, partials;

                if (!options.partial) {
                    helpers = options.helpers;
                    partials = options.partials;
                }
                var result = templateSpec.call(
                container, namespace, context, helpers, partials, options.data);

                if (!options.partial) {
                    env.VM.checkRevision(container.compilerInfo);
                }

                return result;
            };
        }

        __exports__.template = template;

        function programWithDepth(i, fn, data /*, $depth */ ) {
            var args = Array.prototype.slice.call(arguments, 3);

            var prog = function (context, options) {
                options = options || {};

                return fn.apply(this, [context, options.data || data].concat(args));
            };
            prog.program = i;
            prog.depth = args.length;
            return prog;
        }

        __exports__.programWithDepth = programWithDepth;

        function program(i, fn, data) {
            var prog = function (context, options) {
                options = options || {};

                return fn(context, options.data || data);
            };
            prog.program = i;
            prog.depth = 0;
            return prog;
        }

        __exports__.program = program;

        function invokePartial(partial, name, context, helpers, partials, data) {
            var options = {
                partial: true,
                helpers: helpers,
                partials: partials,
                data: data
            };

            if (partial === undefined) {
                throw new Exception("The partial " + name + " could not be found");
            } else if (partial instanceof Function) {
                return partial(context, options);
            }
        }

        __exports__.invokePartial = invokePartial;

        function noop() {
            return "";
        }

        __exports__.noop = noop;
        return __exports__;
    })(__module2__, __module4__, __module1__);

    // handlebars.runtime.js
    var __module0__ = (function (__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__) {
        "use strict";
        var __exports__; /*globals Handlebars: true */
        var base = __dependency1__;

        // Each of these augment the Handlebars object. No need to setup here.
        // (This is done to easily share code between commonjs and browse envs)
        var SafeString = __dependency2__;
        var Exception = __dependency3__;
        var Utils = __dependency4__;
        var runtime = __dependency5__;

        // For compatibility and usage outside of module systems, make the Handlebars object a namespace
        var create = function () {
            var hb = new base.HandlebarsEnvironment();

            Utils.extend(hb, base);
            hb.SafeString = SafeString;
            hb.Exception = Exception;
            hb.Utils = Utils;

            hb.VM = runtime;
            hb.template = function (spec) {
                return runtime.template(spec, hb);
            };

            return hb;
        };

        var Handlebars = create();
        Handlebars.create = create;

        __exports__ = Handlebars;
        return __exports__;
    })(__module1__, __module3__, __module4__, __module2__, __module5__);

    return __module0__;
})();


Handlebars.getTemplate = function (name, raw) {
    sendBack = HandlebarsTemplates['handlebars/' + name]
    return sendBack
};

Handlebars.registerHelper('list', function (items, options) {
    var out = "<ul>";

    for (var i = 0, l = items.length; i < l; i++) {
        out = out + "<li>" + options.fn(items[i]) + "</li>";
    }

    return out + "</ul>";
});

// debug helper
// usage: {{debug}} or {{debug someValue}}
// from: @commondream (http://thinkvitamin.com/code/handlebars-js-part-3-tips-and-tricks/)
Handlebars.registerHelper("debug", function (optionalValue) {
    console.log("Current Context");
    console.log("====================");
    console.log(this);

    if (optionalValue) {
        console.log("Value");
        console.log("====================");
        console.log(optionalValue);
    }
});


//  return the first item of a list only
// usage: {{#first items}}{{name}}{{/first}}
Handlebars.registerHelper('first', function (context, block) {
    return block(context[0]);
});



// a limited 'each' loop.
// usage: {{#limit items offset="1" limit="5"}} : items 1 thru 6
// usage: {{#limit items limit="10"}} : items 0 thru 9
// usage: {{#limit items offset="3"}} : items 3 thru context.length
// defaults are offset=0, limit=5
Handlebars.registerHelper('limit', function (context, options) {

    var ret = "",
        offset = parseInt(options.hash.offset) || 0,
        limit = parseInt(options.hash.limit) || 5,
        i = (offset < context.length) ? offset : 0,
        j = ((limit + offset) < context.length) ? (limit + offset) : context.length;

    for (i, j; i < j; i++) {
        ret += options.fn(context[i]);
    }

    return ret;
});


// return a url without http:// or https:// or //
Handlebars.registerHelper('protocolLess', function (context) {

    // url = context.replace(/\/\//g, "");
    url = context.replace(/(.*?)\/\//, "");

    return new Handlebars.SafeString(
    url);
})

// return just the site from a url
Handlebars.registerHelper('justSite', function (context) {

    // siteArray = context.replace(/\/\//g, "");
    siteArray = context.replace(/(.*?)\/\//, "");
    siteArray = siteArray.split('/');
    siteArray = siteArray[0];

    return new Handlebars.SafeString(
    siteArray);
})

//  return a comma-serperated list from an iterable object
// usage: {{#toSentance tags}}{{name}}{{/toSentance}}
Handlebars.registerHelper('toSentance', function (context, block) {
    var ret = "";
    for (var i = 0, j = context.length; i < j; i++) {
        ret = ret + block(context[i]);
        if (i < j - 1) {
            ret = ret + ", ";
        };
    }
    return ret;
});


/*!
 * typeahead.js 0.10.1
 * https://github.com/twitter/typeahead.js
 * Copyright 2013 Twitter, Inc. and other contributors; Licensed MIT
 */

(function ($) {
    var _ = {
        isMsie: function () {
            return /(msie|trident)/i.test(navigator.userAgent) ? navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2] : false;
        },
        isBlankString: function (str) {
            return !str || /^\s*$/.test(str);
        },
        escapeRegExChars: function (str) {
            return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
        },
        isString: function (obj) {
            return typeof obj === "string";
        },
        isNumber: function (obj) {
            return typeof obj === "number";
        },
        isArray: $.isArray,
        isFunction: $.isFunction,
        isObject: $.isPlainObject,
        isUndefined: function (obj) {
            return typeof obj === "undefined";
        },
        bind: $.proxy,
        each: function (collection, cb) {
            $.each(collection, reverseArgs);

            function reverseArgs(index, value) {
                return cb(value, index);
            }
        },
        map: $.map,
        filter: $.grep,
        every: function (obj, test) {
            var result = true;
            if (!obj) {
                return result;
            }
            $.each(obj, function (key, val) {
                if (!(result = test.call(null, val, key, obj))) {
                    return false;
                }
            });
            return !!result;
        },
        some: function (obj, test) {
            var result = false;
            if (!obj) {
                return result;
            }
            $.each(obj, function (key, val) {
                if (result = test.call(null, val, key, obj)) {
                    return false;
                }
            });
            return !!result;
        },
        mixin: $.extend,
        getUniqueId: function () {
            var counter = 0;
            return function () {
                return counter++;
            };
        }(),
        templatify: function templatify(obj) {
            return $.isFunction(obj) ? obj : template;

            function template() {
                return String(obj);
            }
        },
        defer: function (fn) {
            setTimeout(fn, 0);
        },
        debounce: function (func, wait, immediate) {
            var timeout, result;
            return function () {
                var context = this,
                    args = arguments,
                    later, callNow;
                later = function () {
                    timeout = null;
                    if (!immediate) {
                        result = func.apply(context, args);
                    }
                };
                callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) {
                    result = func.apply(context, args);
                }
                return result;
            };
        },
        throttle: function (func, wait) {
            var context, args, timeout, result, previous, later;
            previous = 0;
            later = function () {
                previous = new Date();
                timeout = null;
                result = func.apply(context, args);
            };
            return function () {
                var now = new Date(),
                    remaining = wait - (now - previous);
                context = this;
                args = arguments;
                if (remaining <= 0) {
                    clearTimeout(timeout);
                    timeout = null;
                    previous = now;
                    result = func.apply(context, args);
                } else if (!timeout) {
                    timeout = setTimeout(later, remaining);
                }
                return result;
            };
        },
        noop: function () {}
    };
    var VERSION = "0.10.1";
    var LruCache = function (root, undefined) {
        function LruCache(maxSize) {
            this.maxSize = maxSize || 100;
            this.size = 0;
            this.hash = {};
            this.list = new List();
        }
        _.mixin(LruCache.prototype, {
            set: function set(key, val) {
                var tailItem = this.list.tail,
                    node;
                if (this.size >= this.maxSize) {
                    this.list.remove(tailItem);
                    delete this.hash[tailItem.key];
                }
                if (node = this.hash[key]) {
                    node.val = val;
                    this.list.moveToFront(node);
                } else {
                    node = new Node(key, val);
                    this.list.add(node);
                    this.hash[key] = node;
                    this.size++;
                }
            },
            get: function get(key) {
                var node = this.hash[key];
                if (node) {
                    this.list.moveToFront(node);
                    return node.val;
                }
            }
        });

        function List() {
            this.head = this.tail = null;
        }
        _.mixin(List.prototype, {
            add: function add(node) {
                if (this.head) {
                    node.next = this.head;
                    this.head.prev = node;
                }
                this.head = node;
                this.tail = this.tail || node;
            },
            remove: function remove(node) {
                node.prev ? node.prev.next = node.next : this.head = node.next;
                node.next ? node.next.prev = node.prev : this.tail = node.prev;
            },
            moveToFront: function (node) {
                this.remove(node);
                this.add(node);
            }
        });

        function Node(key, val) {
            this.key = key;
            this.val = val;
            this.prev = this.next = null;
        }
        return LruCache;
    }(this);
    var PersistentStorage = function () {
        var ls, methods;
        try {
            ls = window.localStorage;
            ls.setItem("~~~", "!");
            ls.removeItem("~~~");
        } catch (err) {
            ls = null;
        }

        function PersistentStorage(namespace) {
            this.prefix = ["__", namespace, "__"].join("");
            this.ttlKey = "__ttl__";
            this.keyMatcher = new RegExp("^" + this.prefix);
        }
        if (ls && window.JSON) {
            methods = {
                _prefix: function (key) {
                    return this.prefix + key;
                },
                _ttlKey: function (key) {
                    return this._prefix(key) + this.ttlKey;
                },
                get: function (key) {
                    if (this.isExpired(key)) {
                        this.remove(key);
                    }
                    return decode(ls.getItem(this._prefix(key)));
                },
                set: function (key, val, ttl) {
                    if (_.isNumber(ttl)) {
                        ls.setItem(this._ttlKey(key), encode(now() + ttl));
                    } else {
                        ls.removeItem(this._ttlKey(key));
                    }
                    return ls.setItem(this._prefix(key), encode(val));
                },
                remove: function (key) {
                    ls.removeItem(this._ttlKey(key));
                    ls.removeItem(this._prefix(key));
                    return this;
                },
                clear: function () {
                    var i, key, keys = [],
                        len = ls.length;
                    for (i = 0; i < len; i++) {
                        if ((key = ls.key(i)).match(this.keyMatcher)) {
                            keys.push(key.replace(this.keyMatcher, ""));
                        }
                    }
                    for (i = keys.length; i--;) {
                        this.remove(keys[i]);
                    }
                    return this;
                },
                isExpired: function (key) {
                    var ttl = decode(ls.getItem(this._ttlKey(key)));
                    return _.isNumber(ttl) && now() > ttl ? true : false;
                }
            };
        } else {
            methods = {
                get: _.noop,
                set: _.noop,
                remove: _.noop,
                clear: _.noop,
                isExpired: _.noop
            };
        }
        _.mixin(PersistentStorage.prototype, methods);
        return PersistentStorage;

        function now() {
            return new Date().getTime();
        }

        function encode(val) {
            return JSON.stringify(_.isUndefined(val) ? null : val);
        }

        function decode(val) {
            return JSON.parse(val);
        }
    }();
    var Transport = function () {
        var pendingRequestsCount = 0,
            pendingRequests = {},
            maxPendingRequests = 6,
            requestCache = new LruCache(10);

        function Transport(o) {
            o = o || {};
            this._send = o.transport ? callbackToDeferred(o.transport) : $.ajax;
            this._get = o.rateLimiter ? o.rateLimiter(this._get) : this._get;
        }
        Transport.setMaxPendingRequests = function setMaxPendingRequests(num) {
            maxPendingRequests = num;
        };
        Transport.resetCache = function clearCache() {
            requestCache = new LruCache(10);
        };
        _.mixin(Transport.prototype, {
            _get: function (url, o, cb) {
                var that = this,
                    jqXhr;
                if (jqXhr = pendingRequests[url]) {
                    jqXhr.done(done);
                } else if (pendingRequestsCount < maxPendingRequests) {
                    pendingRequestsCount++;
                    pendingRequests[url] = this._send(url, o).done(done).always(always);
                } else {
                    this.onDeckRequestArgs = [].slice.call(arguments, 0);
                }

                function done(resp) {
                    cb && cb(resp);
                    requestCache.set(url, resp);
                }

                function always() {
                    pendingRequestsCount--;
                    delete pendingRequests[url];
                    if (that.onDeckRequestArgs) {
                        that._get.apply(that, that.onDeckRequestArgs);
                        that.onDeckRequestArgs = null;
                    }
                }
            },
            get: function (url, o, cb) {
                var that = this,
                    resp;
                if (_.isFunction(o)) {
                    cb = o;
                    o = {};
                }
                if (resp = requestCache.get(url)) {
                    _.defer(function () {
                        cb && cb(resp);
                    });
                } else {
                    this._get(url, o, cb);
                }
                return !!resp;
            }
        });
        return Transport;

        function callbackToDeferred(fn) {
            return function customSendWrapper(url, o) {
                var deferred = $.Deferred();
                fn(url, o, onSuccess, onError);
                return deferred;

                function onSuccess(resp) {
                    _.defer(function () {
                        deferred.resolve(resp);
                    });
                }

                function onError(err) {
                    _.defer(function () {
                        deferred.reject(err);
                    });
                }
            };
        }
    }();
    var SearchIndex = function () {
        function SearchIndex(o) {
            o = o || {};
            if (!o.datumTokenizer || !o.queryTokenizer) {
                $.error("datumTokenizer and queryTokenizer are both required");
            }
            this.datumTokenizer = o.datumTokenizer;
            this.queryTokenizer = o.queryTokenizer;
            this.datums = [];
            this.trie = newNode();
        }
        _.mixin(SearchIndex.prototype, {
            bootstrap: function bootstrap(o) {
                this.datums = o.datums;
                this.trie = o.trie;
            },
            add: function (data) {
                var that = this;
                data = _.isArray(data) ? data : [data];
                _.each(data, function (datum) {
                    var id, tokens;
                    id = that.datums.push(datum) - 1;
                    tokens = normalizeTokens(that.datumTokenizer(datum));
                    _.each(tokens, function (token) {
                        var node, chars, ch, ids;
                        node = that.trie;
                        chars = token.split("");
                        while (ch = chars.shift()) {
                            node = node.children[ch] || (node.children[ch] = newNode());
                            node.ids.push(id);
                        }
                    });
                });
            },
            get: function get(query) {
                var that = this,
                    tokens, matches;
                tokens = normalizeTokens(this.queryTokenizer(query));
                _.each(tokens, function (token) {
                    var node, chars, ch, ids;
                    if (matches && matches.length === 0) {
                        return false;
                    }
                    node = that.trie;
                    chars = token.split("");
                    while (node && (ch = chars.shift())) {
                        node = node.children[ch];
                    }
                    if (node && chars.length === 0) {
                        ids = node.ids.slice(0);
                        matches = matches ? getIntersection(matches, ids) : ids;
                    } else {
                        matches = [];
                        return false;
                    }
                });
                return matches ? _.map(unique(matches), function (id) {
                    return that.datums[id];
                }) : [];
            },
            serialize: function serialize() {
                return {
                    datums: this.datums,
                    trie: this.trie
                };
            }
        });
        return SearchIndex;

        function normalizeTokens(tokens) {
            tokens = _.filter(tokens, function (token) {
                return !!token;
            });
            tokens = _.map(tokens, function (token) {
                return token.toLowerCase();
            });
            return tokens;
        }

        function newNode() {
            return {
                ids: [],
                children: {}
            };
        }

        function unique(array) {
            var seen = {},
                uniques = [];
            for (var i = 0; i < array.length; i++) {
                if (!seen[array[i]]) {
                    seen[array[i]] = true;
                    uniques.push(array[i]);
                }
            }
            return uniques;
        }

        function getIntersection(arrayA, arrayB) {
            var ai = 0,
                bi = 0,
                intersection = [];
            arrayA = arrayA.sort(compare);
            arrayB = arrayB.sort(compare);
            while (ai < arrayA.length && bi < arrayB.length) {
                if (arrayA[ai] < arrayB[bi]) {
                    ai++;
                } else if (arrayA[ai] > arrayB[bi]) {
                    bi++;
                } else {
                    intersection.push(arrayA[ai]);
                    ai++;
                    bi++;
                }
            }
            return intersection;

            function compare(a, b) {
                return a - b;
            }
        }
    }();
    var oParser = function () {
        return {
            local: getLocal,
            prefetch: getPrefetch,
            remote: getRemote
        };

        function getLocal(o) {
            var local = o.local || null;
            if (_.isFunction(local)) {
                local = local.call(null);
            }
            return local;
        }

        function getPrefetch(o) {
            var prefetch, defaults;
            defaults = {
                url: null,
                thumbprint: "",
                ttl: 24 * 60 * 60 * 1e3,
                filter: null,
                ajax: {}
            };
            if (prefetch = o.prefetch || null) {
                prefetch = _.isString(prefetch) ? {
                    url: prefetch
                } : prefetch;
                prefetch = _.mixin(defaults, prefetch);
                prefetch.thumbprint = VERSION + prefetch.thumbprint;
                prefetch.ajax.type = prefetch.ajax.type || "GET";
                prefetch.ajax.dataType = prefetch.ajax.dataType || "json";
                !prefetch.url && $.error("prefetch requires url to be set");
            }
            return prefetch;
        }

        function getRemote(o) {
            var remote, defaults;
            defaults = {
                url: null,
                wildcard: "%QUERY",
                replace: null,
                rateLimitBy: "debounce",
                rateLimitWait: 300,
                send: null,
                filter: null,
                ajax: {}
            };
            if (remote = o.remote || null) {
                remote = _.isString(remote) ? {
                    url: remote
                } : remote;
                remote = _.mixin(defaults, remote);
                remote.rateLimiter = /^throttle$/i.test(remote.rateLimitBy) ? byThrottle(remote.rateLimitWait) : byDebounce(remote.rateLimitWait);
                remote.ajax.type = remote.ajax.type || "GET";
                remote.ajax.dataType = remote.ajax.dataType || "json";
                delete remote.rateLimitBy;
                delete remote.rateLimitWait;
                !remote.url && $.error("remote requires url to be set");
            }
            return remote;

            function byDebounce(wait) {
                return function (fn) {
                    return _.debounce(fn, wait);
                };
            }

            function byThrottle(wait) {
                return function (fn) {
                    return _.throttle(fn, wait);
                };
            }
        }
    }();
    var Bloodhound = window.Bloodhound = function () {
        var keys;
        keys = {
            data: "data",
            protocol: "protocol",
            thumbprint: "thumbprint"
        };

        function Bloodhound(o) {
            if (!o || !o.local && !o.prefetch && !o.remote) {
                $.error("one of local, prefetch, or remote is required");
            }
            this.limit = o.limit || 5;
            this.sorter = getSorter(o.sorter);
            this.dupDetector = o.dupDetector || ignoreDuplicates;
            this.local = oParser.local(o);
            this.prefetch = oParser.prefetch(o);
            this.remote = oParser.remote(o);
            this.cacheKey = this.prefetch ? this.prefetch.cacheKey || this.prefetch.url : null;
            this.index = new SearchIndex({
                datumTokenizer: o.datumTokenizer,
                queryTokenizer: o.queryTokenizer
            });
            this.storage = this.cacheKey ? new PersistentStorage(this.cacheKey) : null;
        }
        Bloodhound.tokenizers = {
            whitespace: function whitespaceTokenizer(s) {
                return s.split(/\s+/);
            },
            nonword: function nonwordTokenizer(s) {
                return s.split(/\W+/);
            }
        };
        _.mixin(Bloodhound.prototype, {
            _loadPrefetch: function loadPrefetch(o) {
                var that = this,
                    serialized, deferred;
                if (serialized = this._readFromStorage(o.thumbprint)) {
                    this.index.bootstrap(serialized);
                    deferred = $.Deferred().resolve();
                } else {
                    deferred = $.ajax(o.url, o.ajax).done(handlePrefetchResponse);
                }
                return deferred;

                function handlePrefetchResponse(resp) {
                    var filtered;
                    filtered = o.filter ? o.filter(resp) : resp;
                    that.add(filtered);
                    that._saveToStorage(that.index.serialize(), o.thumbprint, o.ttl);
                }
            },
            _getFromRemote: function getFromRemote(query, cb) {
                var that = this,
                    url, uriEncodedQuery;
                query = query || "";
                uriEncodedQuery = encodeURIComponent(query);
                url = this.remote.replace ? this.remote.replace(this.remote.url, query) : this.remote.url.replace(this.remote.wildcard, uriEncodedQuery);
                return this.transport.get(url, this.remote.ajax, handleRemoteResponse);

                function handleRemoteResponse(resp) {
                    var filtered = that.remote.filter ? that.remote.filter(resp) : resp;
                    cb(filtered);
                }
            },
            _saveToStorage: function saveToStorage(data, thumbprint, ttl) {
                if (this.storage) {
                    this.storage.set(keys.data, data, ttl);
                    this.storage.set(keys.protocol, location.protocol, ttl);
                    this.storage.set(keys.thumbprint, thumbprint, ttl);
                }
            },
            _readFromStorage: function readFromStorage(thumbprint) {
                var stored = {},
                    isExpired;
                if (this.storage) {
                    stored.data = this.storage.get(keys.data);
                    stored.protocol = this.storage.get(keys.protocol);
                    stored.thumbprint = this.storage.get(keys.thumbprint);
                }
                isExpired = stored.thumbprint !== thumbprint || stored.protocol !== location.protocol;
                return stored.data && !isExpired ? stored.data : null;
            },
            initialize: function initialize() {
                var that = this,
                    deferred;
                deferred = this.prefetch ? this._loadPrefetch(this.prefetch) : $.Deferred().resolve();
                this.local && deferred.done(addLocalToIndex);
                this.transport = this.remote ? new Transport(this.remote) : null;
                this.initialize = function initialize() {
                    return deferred.promise();
                };
                return deferred.promise();

                function addLocalToIndex() {
                    that.add(that.local);
                }
            },
            add: function add(data) {
                this.index.add(data);
            },
            get: function get(query, cb) {
                var that = this,
                    matches, cacheHit = false;
                matches = this.index.get(query);
                matches = this.sorter(matches).slice(0, this.limit);
                if (matches.length < this.limit && this.transport) {
                    cacheHit = this._getFromRemote(query, returnRemoteMatches);
                }!cacheHit && cb && cb(matches);

                function returnRemoteMatches(remoteMatches) {
                    var matchesWithBackfill = matches.slice(0);
                    _.each(remoteMatches, function (remoteMatch) {
                        var isDuplicate;
                        isDuplicate = _.some(matchesWithBackfill, function (match) {
                            return that.dupDetector(remoteMatch, match);
                        });
                        !isDuplicate && matchesWithBackfill.push(remoteMatch);
                        return matchesWithBackfill.length < that.limit;
                    });
                    cb && cb(that.sorter(matchesWithBackfill));
                }
            },
            ttAdapter: function ttAdapter() {
                return _.bind(this.get, this);
            }
        });
        return Bloodhound;

        function getSorter(sortFn) {
            return _.isFunction(sortFn) ? sort : noSort;

            function sort(array) {
                return array.sort(sortFn);
            }

            function noSort(array) {
                return array;
            }
        }

        function ignoreDuplicates() {
            return false;
        }
    }();
    var html = {
        wrapper: '<div class="twitter-typeahead"></div>',
        dropdown: '<span class="tt-dropdown-menu  search-helper"></span>',
        dataset: '<div class="tt-dataset-%CLASS% "></div>',
        suggestions: '<ul class="tt-suggestions"></ul>',
        suggestion: '<li class="tt-suggestion ">%BODY%</li>'
    };
    var css = {
        wrapper: {
            position: "relative",
            display: "inline-block"
        },
        hint: {
            // position: "absolute",
            // top: "0",
            // left: "0",
            // borderColor: "transparent",
            // boxShadow: "none"
        },
        input: {
            // position: "relative",
            // verticalAlign: "top",
            // backgroundColor: "transparent"
        },
        inputWithNoHint: {
            // position: "relative",
            // verticalAlign: "top"
        },
        dropdown: {
            // position: "absolute",
            zIndex: "100",
            // left: "-85px",
            // right: "0",
            display: "none"
        },
        suggestions: {
            display: "inline-block"
        },
        suggestion: {
            whiteSpace: "nowrap",
            display: "inline-block",
            cursor: "pointer"
        },
        suggestionChild: {
            whiteSpace: "normal"
        },
        ltr: {
            // left: "0",
            // right: "auto"
        },
        rtl: {
            left: "auto",
            right: " 0"
        }
    };
    if (_.isMsie()) {
        _.mixin(css.input, {
            backgroundImage: "url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)"
        });
    }
    if (_.isMsie() && _.isMsie() <= 7) {
        _.mixin(css.input, {
            marginTop: "-1px"
        });
    }
    var EventBus = function () {
        var namespace = "typeahead:";

        function EventBus(o) {
            if (!o || !o.el) {
                $.error("EventBus initialized without el");
            }
            this.$el = $(o.el);
        }
        _.mixin(EventBus.prototype, {
            trigger: function (type) {
                var args = [].slice.call(arguments, 1);
                this.$el.trigger(namespace + type, args);
            }
        });
        return EventBus;
    }();
    var EventEmitter = function () {
        var splitter = /\s+/,
            nextTick = getNextTick();
        return {
            onSync: onSync,
            onAsync: onAsync,
            off: off,
            trigger: trigger
        };

        function on(method, types, cb, context) {
            var type;
            if (!cb) {
                return this;
            }
            types = types.split(splitter);
            cb = context ? bindContext(cb, context) : cb;
            this._callbacks = this._callbacks || {};
            while (type = types.shift()) {
                this._callbacks[type] = this._callbacks[type] || {
                    sync: [],
                    async: []
                };
                this._callbacks[type][method].push(cb);
            }
            return this;
        }

        function onAsync(types, cb, context) {
            return on.call(this, "async", types, cb, context);
        }

        function onSync(types, cb, context) {
            return on.call(this, "sync", types, cb, context);
        }

        function off(types) {
            var type;
            if (!this._callbacks) {
                return this;
            }
            types = types.split(splitter);
            while (type = types.shift()) {
                delete this._callbacks[type];
            }
            return this;
        }

        function trigger(types) {
            var that = this,
                type, callbacks, args, syncFlush, asyncFlush;
            if (!this._callbacks) {
                return this;
            }
            types = types.split(splitter);
            args = [].slice.call(arguments, 1);
            while ((type = types.shift()) && (callbacks = this._callbacks[type])) {
                syncFlush = getFlush(callbacks.sync, this, [type].concat(args));
                asyncFlush = getFlush(callbacks.async, this, [type].concat(args));
                syncFlush() && nextTick(asyncFlush);
            }
            return this;
        }

        function getFlush(callbacks, context, args) {
            return flush;

            function flush() {
                var cancelled;
                for (var i = 0; !cancelled && i < callbacks.length; i += 1) {
                    cancelled = callbacks[i].apply(context, args) === false;
                }
                return !cancelled;
            }
        }

        function getNextTick() {
            var nextTickFn, messageChannel;
            if (window.setImmediate) {
                nextTickFn = function nextTickSetImmediate(fn) {
                    setImmediate(function () {
                        fn();
                    });
                };
            } else {
                nextTickFn = function nextTickSetTimeout(fn) {
                    setTimeout(function () {
                        fn();
                    }, 0);
                };
            }
            return nextTickFn;
        }

        function bindContext(fn, context) {
            return fn.bind ? fn.bind(context) : function () {
                fn.apply(context, [].slice.call(arguments, 0));
            };
        }
    }();
    var highlight = function (doc) {
        var defaults = {
            node: null,
            pattern: null,
            tagName: "strong",
            className: null,
            wordsOnly: false,
            caseSensitive: false
        };
        return function hightlight(o) {
            var regex;
            o = _.mixin({}, defaults, o);
            if (!o.node || !o.pattern) {
                return;
            }
            o.pattern = _.isArray(o.pattern) ? o.pattern : [o.pattern];
            regex = getRegex(o.pattern, o.caseSensitive, o.wordsOnly);
            traverse(o.node, hightlightTextNode);

            function hightlightTextNode(textNode) {
                var match, patternNode;
                if (match = regex.exec(textNode.data)) {
                    wrapperNode = doc.createElement(o.tagName);
                    o.className && (wrapperNode.className = o.className);
                    patternNode = textNode.splitText(match.index);
                    patternNode.splitText(match[0].length);
                    wrapperNode.appendChild(patternNode.cloneNode(true));
                    textNode.parentNode.replaceChild(wrapperNode, patternNode);
                }
                return !!match;
            }

            function traverse(el, hightlightTextNode) {
                var childNode, TEXT_NODE_TYPE = 3;
                for (var i = 0; i < el.childNodes.length; i++) {
                    childNode = el.childNodes[i];
                    if (childNode.nodeType === TEXT_NODE_TYPE) {
                        i += hightlightTextNode(childNode) ? 1 : 0;
                    } else {
                        traverse(childNode, hightlightTextNode);
                    }
                }
            }
        };

        function getRegex(patterns, caseSensitive, wordsOnly) {
            var escapedPatterns = [],
                regexStr;
            for (var i = 0; i < patterns.length; i++) {
                escapedPatterns.push(_.escapeRegExChars(patterns[i]));
            }
            regexStr = wordsOnly ? "\\b(" + escapedPatterns.join("|") + ")\\b" : "(" + escapedPatterns.join("|") + ")";
            return caseSensitive ? new RegExp(regexStr) : new RegExp(regexStr, "i");
        }
    }(window.document);
    var Input = function () {
        var specialKeyCodeMap;
        specialKeyCodeMap = {
            9: "tab",
            27: "esc",
            37: "left",
            39: "right",
            13: "enter",
            38: "up",
            40: "down"
        };

        function Input(o) {
            var that = this,
                onBlur, onFocus, onKeydown, onInput;
            o = o || {};
            if (!o.input) {
                $.error("input is missing");
            }
            onBlur = _.bind(this._onBlur, this);
            onFocus = _.bind(this._onFocus, this);
            onKeydown = _.bind(this._onKeydown, this);
            onInput = _.bind(this._onInput, this);
            this.$hint = $(o.hint);
            this.$input = $(o.input).on("blur.tt", onBlur).on("focus.tt", onFocus).on("keydown.tt", onKeydown);
            if (this.$hint.length === 0) {
                this.setHintValue = this.getHintValue = this.clearHint = _.noop;
            }
            if (!_.isMsie()) {
                this.$input.on("input.tt", onInput);
            } else {
                this.$input.on("keydown.tt keypress.tt cut.tt paste.tt", function ($e) {
                    if (specialKeyCodeMap[$e.which || $e.keyCode]) {
                        return;
                    }
                    _.defer(_.bind(that._onInput, that, $e));
                });
            }
            this.query = this.$input.val();
            this.$overflowHelper = buildOverflowHelper(this.$input);
        }
        Input.normalizeQuery = function (str) {
            return (str || "").replace(/^\s*/g, "").replace(/\s{2,}/g, " ");
        };
        _.mixin(Input.prototype, EventEmitter, {
            _onBlur: function onBlur($e) {
                this.resetInputValue();
                this.trigger("blurred");
            },
            _onFocus: function onFocus($e) {
                this.trigger("focused");
            },
            _onKeydown: function onKeydown($e) {
                var keyName = specialKeyCodeMap[$e.which || $e.keyCode];
                this._managePreventDefault(keyName, $e);
                if (keyName && this._shouldTrigger(keyName, $e)) {
                    this.trigger(keyName + "Keyed", $e);
                }
            },
            _onInput: function onInput($e) {
                this._checkInputValue();
            },
            _managePreventDefault: function managePreventDefault(keyName, $e) {
                var preventDefault, hintValue, inputValue;
                switch (keyName) {
                case "tab":
                    hintValue = this.getHintValue();
                    inputValue = this.getInputValue();
                    preventDefault = hintValue && hintValue !== inputValue && !withModifier($e);
                    break;

                case "up":
                case "down":
                    preventDefault = !withModifier($e);
                    break;

                default:
                    preventDefault = false;
                }
                preventDefault && $e.preventDefault();
            },
            _shouldTrigger: function shouldTrigger(keyName, $e) {
                var trigger;
                switch (keyName) {
                case "tab":
                    trigger = !withModifier($e);
                    break;

                default:
                    trigger = true;
                }
                return trigger;
            },
            _checkInputValue: function checkInputValue() {
                var inputValue, areEquivalent, hasDifferentWhitespace;
                inputValue = this.getInputValue();
                areEquivalent = areQueriesEquivalent(inputValue, this.query);
                hasDifferentWhitespace = areEquivalent ? this.query.length !== inputValue.length : false;
                if (!areEquivalent) {
                    this.trigger("queryChanged", this.query = inputValue);
                } else if (hasDifferentWhitespace) {
                    this.trigger("whitespaceChanged", this.query);
                }
            },
            focus: function focus() {
                this.$input.focus();
            },
            blur: function blur() {
                this.$input.blur();
            },
            getQuery: function getQuery() {
                return this.query;
            },
            setQuery: function setQuery(query) {
                this.query = query;
            },
            getInputValue: function getInputValue() {
                return this.$input.val();
            },
            setInputValue: function setInputValue(value, silent) {
                this.$input.val(value);
                !silent && this._checkInputValue();
            },
            getHintValue: function getHintValue() {
                return this.$hint.val();
            },
            setHintValue: function setHintValue(value) {
                this.$hint.val(value);
            },
            resetInputValue: function resetInputValue() {
                this.$input.val(this.query);
            },
            clearHint: function clearHint() {
                this.$hint.val("");
            },
            getLanguageDirection: function getLanguageDirection() {
                return (this.$input.css("direction") || "ltr").toLowerCase();
            },
            hasOverflow: function hasOverflow() {
                var constraint = this.$input.width() - 2;
                this.$overflowHelper.text(this.getInputValue());
                return this.$overflowHelper.width() >= constraint;
            },
            isCursorAtEnd: function () {
                var valueLength, selectionStart, range;
                valueLength = this.$input.val().length;
                selectionStart = this.$input[0].selectionStart;
                if (_.isNumber(selectionStart)) {
                    return selectionStart === valueLength;
                } else if (document.selection) {
                    range = document.selection.createRange();
                    range.moveStart("character", -valueLength);
                    return valueLength === range.text.length;
                }
                return true;
            },
            destroy: function destroy() {
                this.$hint.off(".tt");
                this.$input.off(".tt");
                this.$hint = this.$input = this.$overflowHelper = null;
            }
        });
        return Input;

        function buildOverflowHelper($input) {
            return $('<pre aria-hidden="true"></pre>').css({
                position: "absolute",
                visibility: "hidden",
                whiteSpace: "nowrap",
                fontFamily: $input.css("font-family"),
                fontSize: $input.css("font-size"),
                fontStyle: $input.css("font-style"),
                fontVariant: $input.css("font-variant"),
                fontWeight: $input.css("font-weight"),
                wordSpacing: $input.css("word-spacing"),
                letterSpacing: $input.css("letter-spacing"),
                textIndent: $input.css("text-indent"),
                textRendering: $input.css("text-rendering"),
                textTransform: $input.css("text-transform")
            }).insertAfter($input);
        }

        function areQueriesEquivalent(a, b) {
            return Input.normalizeQuery(a) === Input.normalizeQuery(b);
        }

        function withModifier($e) {
            return $e.altKey || $e.ctrlKey || $e.metaKey || $e.shiftKey;
        }
    }();
    var Dataset = function () {
        var datasetKey = "ttDataset",
            valueKey = "ttValue",
            datumKey = "ttDatum";

        function Dataset(o) {
            o = o || {};
            o.templates = o.templates || {};
            if (!o.source) {
                $.error("missing source");
            }
            if (o.name && !isValidName(o.name)) {
                $.error("invalid dataset name: " + o.name);
            }
            this.query = null;
            this.highlight = !! o.highlight;
            this.name = o.name || _.getUniqueId();
            this.source = o.source;
            this.displayFn = getDisplayFn(o.display || o.displayKey);
            this.templates = getTemplates(o.templates, this.displayFn);
            this.$el = $(html.dataset.replace("%CLASS%", this.name));
        }
        Dataset.extractDatasetName = function extractDatasetName(el) {
            return $(el).data(datasetKey);
        };
        Dataset.extractValue = function extractDatum(el) {
            return $(el).data(valueKey);
        };
        Dataset.extractDatum = function extractDatum(el) {
            return $(el).data(datumKey);
        };
        _.mixin(Dataset.prototype, EventEmitter, {
            _render: function render(query, suggestions) {
                if (!this.$el) {
                    return;
                }
                var that = this,
                    hasSuggestions;
                this.$el.empty();
                hasSuggestions = suggestions && suggestions.length;
                if (!hasSuggestions && this.templates.empty) {
                    this.$el.html(getEmptyHtml()).prepend(that.templates.header ? getHeaderHtml() : null).append(that.templates.footer ? getFooterHtml() : null);
                } else if (hasSuggestions) {
                    this.$el.html(getSuggestionsHtml()).prepend(that.templates.header ? getHeaderHtml() : null).append(that.templates.footer ? getFooterHtml() : null);
                }
                this.trigger("rendered");

                function getEmptyHtml() {
                    return that.templates.empty({
                        query: query,
                        isEmpty: true
                    });
                }

                function getSuggestionsHtml() {
                    var $suggestions, nodes;
                    $suggestions = $(html.suggestions).css(css.suggestions);
                    nodes = _.map(suggestions, getSuggestionNode);
                    $suggestions.append.apply($suggestions, nodes);
                    that.highlight && highlight({
                        node: $suggestions[0],
                        pattern: query
                    });
                    return $suggestions;

                    function getSuggestionNode(suggestion) {
                        var $el, innerHtml, outerHtml;
                        innerHtml = that.templates.suggestion(suggestion);
                        outerHtml = html.suggestion.replace("%BODY%", innerHtml);
                        $el = $(outerHtml).data(datasetKey, that.name).data(valueKey, that.displayFn(suggestion)).data(datumKey, suggestion);
                        $el.children().each(function () {
                            $(this).css(css.suggestionChild);
                        });
                        return $el;
                    }
                }

                function getHeaderHtml() {
                    return that.templates.header({
                        query: query,
                        isEmpty: !hasSuggestions
                    });
                }

                function getFooterHtml() {
                    return that.templates.footer({
                        query: query,
                        isEmpty: !hasSuggestions
                    });
                }
            },
            getRoot: function getRoot() {
                return this.$el;
            },
            update: function update(query) {
                var that = this;
                this.query = query;
                this.source(query, renderIfQueryIsSame);

                function renderIfQueryIsSame(suggestions) {
                    query === that.query && that._render(query, suggestions);
                }
            },
            clear: function clear() {
                this._render(this.query || "");
            },
            isEmpty: function isEmpty() {
                return this.$el.is(":empty");
            },
            destroy: function destroy() {
                this.$el = null;
            }
        });
        return Dataset;

        function getDisplayFn(display) {
            display = display || "value";
            return _.isFunction(display) ? display : displayFn;

            function displayFn(obj) {
                return obj[display];
            }
        }

        function getTemplates(templates, displayFn) {
            return {
                empty: templates.empty && _.templatify(templates.empty),
                header: templates.header && _.templatify(templates.header),
                footer: templates.footer && _.templatify(templates.footer),
                suggestion: templates.suggestion || suggestionTemplate
            };

            function suggestionTemplate(context) {
                return "<p>" + displayFn(context) + "</p>";
            }
        }

        function isValidName(str) {
            return /^[_a-zA-Z0-9-]+$/.test(str);
        }
    }();
    var Dropdown = function () {
        function Dropdown(o) {
            var that = this,
                onSuggestionClick, onSuggestionMouseEnter, onSuggestionMouseLeave;
            o = o || {};
            if (!o.menu) {
                $.error("menu is required");
            }
            this.isOpen = false;
            this.isEmpty = true;
            this.datasets = _.map(o.datasets, initializeDataset);
            onSuggestionClick = _.bind(this._onSuggestionClick, this);
            onSuggestionMouseEnter = _.bind(this._onSuggestionMouseEnter, this);
            onSuggestionMouseLeave = _.bind(this._onSuggestionMouseLeave, this);
            this.$menu = $(o.menu).on("click.tt", ".tt-suggestion", onSuggestionClick).on("mouseenter.tt", ".tt-suggestion", onSuggestionMouseEnter).on("mouseleave.tt", ".tt-suggestion", onSuggestionMouseLeave);
            _.each(this.datasets, function (dataset) {
                that.$menu.append(dataset.getRoot());
                dataset.onSync("rendered", that._onRendered, that);
            });
        }
        _.mixin(Dropdown.prototype, EventEmitter, {
            _onSuggestionClick: function onSuggestionClick($e) {
                this.trigger("suggestionClicked", $($e.currentTarget));
            },
            _onSuggestionMouseEnter: function onSuggestionMouseEnter($e) {
                this._removeCursor();
                this._setCursor($($e.currentTarget), true);
            },
            _onSuggestionMouseLeave: function onSuggestionMouseLeave($e) {
                this._removeCursor();
            },
            _onRendered: function onRendered() {
                this.isEmpty = _.every(this.datasets, isDatasetEmpty);
                this.isEmpty ? this._hide() : this.isOpen && this._show();
                this.trigger("datasetRendered");

                function isDatasetEmpty(dataset) {
                    return dataset.isEmpty();
                }
            },
            _hide: function () {
                this.$menu.hide();
            },
            _show: function () {
                this.$menu.css("display", "block");
            },
            _getSuggestions: function getSuggestions() {
                return this.$menu.find(".tt-suggestion");
            },
            _getCursor: function getCursor() {
                return this.$menu.find(".tt-cursor").first();
            },
            _setCursor: function setCursor($el, silent) {
                $el.first().addClass("tt-cursor");
                !silent && this.trigger("cursorMoved");
            },
            _removeCursor: function removeCursor() {
                this._getCursor().removeClass("tt-cursor");
            },
            _moveCursor: function moveCursor(increment) {
                var $suggestions, $oldCursor, newCursorIndex, $newCursor;
                if (!this.isOpen) {
                    return;
                }
                $oldCursor = this._getCursor();
                $suggestions = this._getSuggestions();
                this._removeCursor();
                newCursorIndex = $suggestions.index($oldCursor) + increment;
                newCursorIndex = (newCursorIndex + 1) % ($suggestions.length + 1) - 1;
                if (newCursorIndex === -1) {
                    this.trigger("cursorRemoved");
                    return;
                } else if (newCursorIndex < -1) {
                    newCursorIndex = $suggestions.length - 1;
                }
                this._setCursor($newCursor = $suggestions.eq(newCursorIndex));
                this._ensureVisible($newCursor);
            },
            _ensureVisible: function ensureVisible($el) {
                var elTop, elBottom, menuScrollTop, menuHeight;
                elTop = $el.position().top;
                elBottom = elTop + $el.outerHeight(true);
                menuScrollTop = this.$menu.scrollTop();
                menuHeight = this.$menu.height() + parseInt(this.$menu.css("paddingTop"), 10) + parseInt(this.$menu.css("paddingBottom"), 10);
                if (elTop < 0) {
                    this.$menu.scrollTop(menuScrollTop + elTop);
                } else if (menuHeight < elBottom) {
                    this.$menu.scrollTop(menuScrollTop + (elBottom - menuHeight));
                }
            },
            close: function close() {
                if (this.isOpen) {
                    this.isOpen = false;
                    this._removeCursor();
                    this._hide();
                    this.trigger("closed");
                }
            },
            open: function open() {
                if (!this.isOpen) {
                    this.isOpen = true;
                    !this.isEmpty && this._show();
                    this.trigger("opened");
                }
            },
            setLanguageDirection: function setLanguageDirection(dir) {
                this.$menu.css(dir === "ltr" ? css.ltr : css.rtl);
            },
            moveCursorUp: function moveCursorUp() {
                this._moveCursor(-1);
            },
            moveCursorDown: function moveCursorDown() {
                this._moveCursor(+1);
            },
            getDatumForSuggestion: function getDatumForSuggestion($el) {
                var datum = null;
                if ($el.length) {
                    datum = {
                        raw: Dataset.extractDatum($el),
                        value: Dataset.extractValue($el),
                        datasetName: Dataset.extractDatasetName($el)
                    };
                }
                return datum;
            },
            getDatumForCursor: function getDatumForCursor() {
                return this.getDatumForSuggestion(this._getCursor().first());
            },
            getDatumForTopSuggestion: function getDatumForTopSuggestion() {
                return this.getDatumForSuggestion(this._getSuggestions().first());
            },
            update: function update(query) {
                _.each(this.datasets, updateDataset);

                function updateDataset(dataset) {
                    dataset.update(query);
                }
            },
            empty: function empty() {
                _.each(this.datasets, clearDataset);
                this.isEmpty = true;

                function clearDataset(dataset) {
                    dataset.clear();
                }
            },
            isVisible: function isVisible() {
                return this.isOpen && !this.isEmpty;
            },
            destroy: function destroy() {
                this.$menu.off(".tt");
                this.$menu = null;
                _.each(this.datasets, destroyDataset);

                function destroyDataset(dataset) {
                    dataset.destroy();
                }
            }
        });
        return Dropdown;

        function initializeDataset(oDataset) {
            return new Dataset(oDataset);
        }
    }();
    var Typeahead = function () {
        var attrsKey = "ttAttrs";

        function Typeahead(o) {
            var $menu, $input, $hint, datasets;
            o = o || {};
            if (!o.input) {
                $.error("missing input");
            }
            this.autoselect = !! o.autoselect;
            this.minLength = _.isNumber(o.minLength) ? o.minLength : 1;
            this.$node = buildDomStructure(o.input, o.withHint);
            $menu = this.$node.find(".tt-dropdown-menu");
            $input = this.$node.find(".tt-input");
            $hint = this.$node.find(".tt-hint");
            this.eventBus = o.eventBus || new EventBus({
                el: $input
            });
            this.dropdown = new Dropdown({
                menu: $menu,
                datasets: o.datasets
            }).onSync("suggestionClicked", this._onSuggestionClicked, this).onSync("cursorMoved", this._onCursorMoved, this).onSync("cursorRemoved", this._onCursorRemoved, this).onSync("opened", this._onOpened, this).onSync("closed", this._onClosed, this).onAsync("datasetRendered", this._onDatasetRendered, this);
            this.input = new Input({
                input: $input,
                hint: $hint
            }).onSync("focused", this._onFocused, this).onSync("blurred", this._onBlurred, this).onSync("enterKeyed", this._onEnterKeyed, this).onSync("tabKeyed", this._onTabKeyed, this).onSync("escKeyed", this._onEscKeyed, this).onSync("upKeyed", this._onUpKeyed, this).onSync("downKeyed", this._onDownKeyed, this).onSync("leftKeyed", this._onLeftKeyed, this).onSync("rightKeyed", this._onRightKeyed, this).onSync("queryChanged", this._onQueryChanged, this).onSync("whitespaceChanged", this._onWhitespaceChanged, this);
            $menu.on("mousedown.tt", function ($e) {
                if (_.isMsie() && _.isMsie() < 9) {
                    $input[0].onbeforedeactivate = function () {
                        window.event.returnValue = false;
                        $input[0].onbeforedeactivate = null;
                    };
                }
                $e.preventDefault();
            });
        }
        _.mixin(Typeahead.prototype, {
            _onSuggestionClicked: function onSuggestionClicked(type, $el) {
                var datum;
                if (datum = this.dropdown.getDatumForSuggestion($el)) {
                    this._select(datum);
                }
            },
            _onCursorMoved: function onCursorMoved() {
                var datum = this.dropdown.getDatumForCursor();
                this.input.clearHint();
                this.input.setInputValue(datum.value, true);
                this.eventBus.trigger("cursorchanged", datum.raw, datum.datasetName);
            },
            _onCursorRemoved: function onCursorRemoved() {
                this.input.resetInputValue();
                this._updateHint();
            },
            _onDatasetRendered: function onDatasetRendered() {
                this._updateHint();
            },
            _onOpened: function onOpened() {
                this._updateHint();
                this.eventBus.trigger("opened");
            },
            _onClosed: function onClosed() {
                this.input.clearHint();
                this.eventBus.trigger("closed");
            },
            _onFocused: function onFocused() {
                this.dropdown.empty();
                this.dropdown.open();
            },
            _onBlurred: function onBlurred() {
                this.dropdown.close();
            },
            _onEnterKeyed: function onEnterKeyed(type, $e) {
                var cursorDatum, topSuggestionDatum;
                cursorDatum = this.dropdown.getDatumForCursor();
                topSuggestionDatum = this.dropdown.getDatumForTopSuggestion();
                if (cursorDatum) {
                    this._select(cursorDatum);
                    $e.preventDefault();
                } else if (this.autoselect && topSuggestionDatum) {
                    this._select(topSuggestionDatum);
                    $e.preventDefault();
                }
            },
            _onTabKeyed: function onTabKeyed(type, $e) {
                var datum;
                if (datum = this.dropdown.getDatumForCursor()) {
                    this._select(datum);
                    $e.preventDefault();
                } else {
                    this._autocomplete();
                }
            },
            _onEscKeyed: function onEscKeyed() {
                this.dropdown.close();
                this.input.resetInputValue();
            },
            _onUpKeyed: function onUpKeyed() {
                var query = this.input.getQuery();
                if (!this.dropdown.isOpen && query.length >= this.minLength) {
                    this.dropdown.update(query);
                }
                this.dropdown.open();
                this.dropdown.moveCursorUp();
            },
            _onDownKeyed: function onDownKeyed() {
                var query = this.input.getQuery();
                if (!this.dropdown.isOpen && query.length >= this.minLength) {
                    this.dropdown.update(query);
                }
                this.dropdown.open();
                this.dropdown.moveCursorDown();
            },
            _onLeftKeyed: function onLeftKeyed() {
                this.dir === "rtl" && this._autocomplete();
            },
            _onRightKeyed: function onRightKeyed() {
                this.dir === "ltr" && this._autocomplete();
            },
            _onQueryChanged: function onQueryChanged(e, query) {
                this.input.clearHint();
                this.dropdown.empty();
                query.length >= this.minLength && this.dropdown.update(query);
                this.dropdown.open();
                this._setLanguageDirection();
            },
            _onWhitespaceChanged: function onWhitespaceChanged() {
                this._updateHint();
                this.dropdown.open();
            },
            _setLanguageDirection: function setLanguageDirection() {
                var dir;
                if (this.dir !== (dir = this.input.getLanguageDirection())) {
                    this.dir = dir;
                    this.$node.css("direction", dir);
                    this.dropdown.setLanguageDirection(dir);
                }
            },
            _updateHint: function updateHint() {
                var datum, inputValue, query, escapedQuery, frontMatchRegEx, match;
                datum = this.dropdown.getDatumForTopSuggestion();
                if (datum && this.dropdown.isVisible() && !this.input.hasOverflow()) {
                    inputValue = this.input.getInputValue();
                    query = Input.normalizeQuery(inputValue);
                    escapedQuery = _.escapeRegExChars(query);
                    frontMatchRegEx = new RegExp("^(?:" + escapedQuery + ")(.*$)", "i");
                    match = frontMatchRegEx.exec(datum.value);
                    this.input.setHintValue(inputValue + (match ? match[1] : ""));
                }
            },
            _autocomplete: function autocomplete() {
                var hint, query, datum;
                hint = this.input.getHintValue();
                query = this.input.getQuery();
                if (hint && query !== hint && this.input.isCursorAtEnd()) {
                    datum = this.dropdown.getDatumForTopSuggestion();
                    datum && this.input.setInputValue(datum.value);
                    this.eventBus.trigger("autocompleted", datum.raw, datum.datasetName);
                }
            },
            _select: function select(datum) {
                this.input.clearHint();
                this.input.setQuery(datum.value);
                this.input.setInputValue(datum.value, true);
                this._setLanguageDirection();
                this.eventBus.trigger("selected", datum.raw, datum.datasetName);
                this.dropdown.close();
                _.defer(_.bind(this.dropdown.empty, this.dropdown));
            },
            open: function open() {
                this.dropdown.open();
            },
            close: function close() {
                this.dropdown.close();
            },
            getQuery: function getQuery() {
                return this.input.getQuery();
            },
            setQuery: function setQuery(val) {
                this.input.setInputValue(val);
            },
            destroy: function destroy() {
                this.input.destroy();
                this.dropdown.destroy();
                destroyDomStructure(this.$node);
                this.$node = null;
            }
        });
        return Typeahead;

        function buildDomStructure(input, withHint) {
            var $input, $wrapper, $dropdown, $hint;
            $input = $(input);
            $wrapper = $(html.wrapper).css(css.wrapper);
            $dropdown = $(html.dropdown).css(css.dropdown);
            $hint = $input.clone().css(css.hint).css(getBackgroundStyles($input));
            $hint.val("").removeData().addClass("tt-hint").removeAttr("id name placeholder").prop("disabled", true).attr({
                autocomplete: "off",
                spellcheck: "false"
            });
            $input.data(attrsKey, {
                dir: $input.attr("dir"),
                autocomplete: $input.attr("autocomplete"),
                spellcheck: $input.attr("spellcheck"),
                style: $input.attr("style")
            });
            $input.addClass("tt-input").attr({
                autocomplete: "off",
                spellcheck: false
            }).css(withHint ? css.input : css.inputWithNoHint);
            try {
                !$input.attr("dir") && $input.attr("dir", "auto");
            } catch (e) {}
            return $input.wrap($wrapper).parent().prepend(withHint ? $hint : null).append($dropdown);
        }

        function getBackgroundStyles($el) {
            return {
                backgroundAttachment: $el.css("background-attachment"),
                backgroundClip: $el.css("background-clip"),
                backgroundColor: $el.css("background-color"),
                backgroundImage: $el.css("background-image"),
                backgroundOrigin: $el.css("background-origin"),
                backgroundPosition: $el.css("background-position"),
                backgroundRepeat: $el.css("background-repeat"),
                backgroundSize: $el.css("background-size")
            };
        }

        function destroyDomStructure($node) {
            var $input = $node.find(".tt-input");
            _.each($input.data(attrsKey), function (val, key) {
                _.isUndefined(val) ? $input.removeAttr(key) : $input.attr(key, val);
            });
            $input.detach().removeData(attrsKey).removeClass("tt-input").insertAfter($node);
            $node.remove();
        }
    }();
    (function () {
        var old, typeaheadKey, methods;
        old = $.fn.typeahead;
        typeaheadKey = "ttTypeahead";
        methods = {
            initialize: function initialize(o, datasets) {
                datasets = _.isArray(datasets) ? datasets : [].slice.call(arguments, 1);
                o = o || {};
                return this.each(attach);

                function attach() {
                    var $input = $(this),
                        eventBus, typeahead;
                    _.each(datasets, function (d) {
                        d.highlight = !! o.highlight;
                    });
                    typeahead = new Typeahead({
                        input: $input,
                        eventBus: eventBus = new EventBus({
                            el: $input
                        }),
                        withHint: _.isUndefined(o.hint) ? true : !! o.hint,
                        minLength: o.minLength,
                        autoselect: o.autoselect,
                        datasets: datasets
                    });
                    $input.data(typeaheadKey, typeahead);
                }
            },
            open: function open() {
                return this.each(openTypeahead);

                function openTypeahead() {
                    var $input = $(this),
                        typeahead;
                    if (typeahead = $input.data(typeaheadKey)) {
                        typeahead.open();
                    }
                }
            },
            close: function close() {
                return this.each(closeTypeahead);

                function closeTypeahead() {
                    var $input = $(this),
                        typeahead;
                    if (typeahead = $input.data(typeaheadKey)) {
                        typeahead.close();
                    }
                }
            },
            val: function val(newVal) {
                return !arguments.length ? getQuery(this.first()) : this.each(setQuery);

                function setQuery() {
                    var $input = $(this),
                        typeahead;
                    if (typeahead = $input.data(typeaheadKey)) {
                        typeahead.setQuery(newVal);
                    }
                }

                function getQuery($input) {
                    var typeahead, query;
                    if (typeahead = $input.data(typeaheadKey)) {
                        query = typeahead.getQuery();
                    }
                    return query;
                }
            },
            destroy: function destroy() {
                return this.each(unattach);

                function unattach() {
                    var $input = $(this),
                        typeahead;
                    if (typeahead = $input.data(typeaheadKey)) {
                        typeahead.destroy();
                        $input.removeData(typeaheadKey);
                    }
                }
            }
        };
        $.fn.typeahead = function (method) {
            if (methods[method]) {
                return methods[method].apply(this, [].slice.call(arguments, 1));
            } else {
                return methods.initialize.apply(this, arguments);
            }
        };
        $.fn.typeahead.noConflict = function noConflict() {
            $.fn.typeahead = old;
            return this;
        };
    })();
})(window.jQuery);



// A cross-browser javascript shim for html5 audio
(function (audiojs, audiojsInstance, container) {
    // Use the path to the audio.js file to create relative paths to the swf and player graphics
    // Remember that some systems (e.g. ruby on rails) append strings like '?1301478336' to asset paths
    var path = (function () {
        var re = new RegExp('audio(\.min)?\.js.*'),
            scripts = document.getElementsByTagName('script');
        for (var i = 0, ii = scripts.length; i < ii; i++) {
            var path = scripts[i].getAttribute('src');
            if (re.test(path)) return path.replace(re, '');
        }
    })();

    // ##The audiojs interface
    // This is the global object which provides an interface for creating new audiojs instances.
    // It also stores all of the construction helper methods and variables.
    container[audiojs] = {
        instanceCount: 0,
        instances: {},
        // The markup for the swf. It is injected into the page if there is not support for the <audio> element. The $ns are placeholders.
        // $1 The name of the flash movie
        // $2 The path to the swf
        // $3 Cache invalidation
        flashSource: '\
      <object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" id="$1" width="1" height="1" name="$1" style="position: absolute; left: -1px;"> \
        <param name="movie" value="$2?playerInstance=' + audiojs + '.instances[\'$1\']&datetime=$3"> \
        <param name="allowscriptaccess" value="always"> \
        <embed name="$1" src="$2?playerInstance=' + audiojs + '.instances[\'$1\']&datetime=$3" width="1" height="1" allowscriptaccess="always"> \
      </object>',

        // ### The main settings object
        // Where all the default settings are stored. Each of these variables and methods can be overwritten by the user-provided options object.
        settings: {
            autoplay: false,
            loop: false,
            preload: true,
            imageLocation: path + 'player-graphics.gif',
            swfLocation: path + 'audiojs.swf',
            useFlash: (function () {
                var a = document.createElement('audio');
                return !(a.canPlayType && a.canPlayType('audio/mpeg;').replace(/no/, ''));
            })(),
            hasFlash: (function () {
                if (navigator.plugins && navigator.plugins.length && navigator.plugins['Shockwave Flash']) {
                    return true;
                } else if (navigator.mimeTypes && navigator.mimeTypes.length) {
                    var mimeType = navigator.mimeTypes['application/x-shockwave-flash'];
                    return mimeType && mimeType.enabledPlugin;
                } else {
                    try {
                        var ax = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');
                        return true;
                    } catch (e) {}
                }
                return false;
            })(),
            // The default markup and classes for creating the player:
            createPlayer: {
                markup: '\
          <div class="play-pause"> \
            <p class="play"></p> \
            <p class="pause"></p> \
            <p class="loading"></p> \
            <p class="error"></p> \
          </div> \
          <div class="scrubber"> \
            <div class="progress"></div> \
            <div class="loaded"></div> \
          </div> \
          <div class="time"> \
            <em class="played">00:00</em>/<strong class="duration">00:00</strong> \
          </div> \
          <div class="error-message"></div>',
                playPauseClass: 'play-pause',
                scrubberClass: 'scrubber',
                progressClass: 'progress',
                loaderClass: 'loaded',
                timeClass: 'time',
                durationClass: 'duration',
                playedClass: 'played',
                errorMessageClass: 'error-message',
                playingClass: 'playing',
                loadingClass: 'loading',
                errorClass: 'error'
            },
            // The css used by the default player. This is is dynamically injected into a <style> tag in the top of the head.
            css: '\
        .audiojs audio { position: absolute; left: -1px; } \
        .audiojs { width: 460px; height: 36px; background: #404040; overflow: hidden; font-family: monospace; font-size: 12px; \
          background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #444), color-stop(0.5, #555), color-stop(0.51, #444), color-stop(1, #444)); \
          background-image: -moz-linear-gradient(center top, #444 0%, #555 50%, #444 51%, #444 100%); \
          -webkit-box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.3); -moz-box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.3); \
          -o-box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.3); box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.3); } \
        .audiojs .play-pause { width: 25px; height: 40px; padding: 4px 6px; margin: 0px; float: left; overflow: hidden; border-right: 1px solid #000; } \
        .audiojs p { display: none; width: 25px; height: 40px; margin: 0px; cursor: pointer; } \
        .audiojs .play { display: block; } \
        .audiojs .scrubber { position: relative; float: left; width: 280px; background: #5a5a5a; height: 14px; margin: 10px; border-top: 1px solid #3f3f3f; border-left: 0px; border-bottom: 0px; overflow: hidden; } \
        .audiojs .progress { position: absolute; top: 0px; left: 0px; height: 14px; width: 0px; background: #ccc; z-index: 1; \
          background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #ccc), color-stop(0.5, #ddd), color-stop(0.51, #ccc), color-stop(1, #ccc)); \
          background-image: -moz-linear-gradient(center top, #ccc 0%, #ddd 50%, #ccc 51%, #ccc 100%); } \
        .audiojs .loaded { position: absolute; top: 0px; left: 0px; height: 14px; width: 0px; background: #000; \
          background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0, #222), color-stop(0.5, #333), color-stop(0.51, #222), color-stop(1, #222)); \
          background-image: -moz-linear-gradient(center top, #222 0%, #333 50%, #222 51%, #222 100%); } \
        .audiojs .time { float: left; height: 36px; line-height: 36px; margin: 0px 0px 0px 6px; padding: 0px 6px 0px 12px; border-left: 1px solid #000; color: #ddd; text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.5); } \
        .audiojs .time em { padding: 0px 2px 0px 0px; color: #f9f9f9; font-style: normal; } \
        .audiojs .time strong { padding: 0px 0px 0px 2px; font-weight: normal; } \
        .audiojs .error-message { float: left; display: none; margin: 0px 10px; height: 36px; width: 400px; overflow: hidden; line-height: 36px; white-space: nowrap; color: #fff; \
          text-overflow: ellipsis; -o-text-overflow: ellipsis; -icab-text-overflow: ellipsis; -khtml-text-overflow: ellipsis; -moz-text-overflow: ellipsis; -webkit-text-overflow: ellipsis; } \
        .audiojs .error-message a { color: #eee; text-decoration: none; padding-bottom: 1px; border-bottom: 1px solid #999; white-space: wrap; } \
        \
        .audiojs .play { background: url("$1") -2px -1px no-repeat; } \
        .audiojs .loading { background: url("$1") -2px -31px no-repeat; } \
        .audiojs .error { background: url("$1") -2px -61px no-repeat; } \
        .audiojs .pause { background: url("$1") -2px -91px no-repeat; } \
        \
        .playing .play, .playing .loading, .playing .error { display: none; } \
        .playing .pause { display: block; } \
        \
        .loading .play, .loading .pause, .loading .error { display: none; } \
        .loading .loading { display: block; } \
        \
        .error .time, .error .play, .error .pause, .error .scrubber, .error .loading { display: none; } \
        .error .error { display: block; } \
        .error .play-pause p { cursor: auto; } \
        .error .error-message { display: block; }',
            // The default event callbacks:
            trackEnded: function (e) {},
            flashError: function () {
                var player = this.settings.createPlayer,
                    errorMessage = getByClass(player.errorMessageClass, this.wrapper),
                    html = 'Missing <a href="http://get.adobe.com/flashplayer/">flash player</a> plugin.';
                if (this.mp3) html += ' <a href="' + this.mp3 + '">Download audio file</a>.';
                container[audiojs].helpers.removeClass(this.wrapper, player.loadingClass);
                container[audiojs].helpers.addClass(this.wrapper, player.errorClass);
                errorMessage.innerHTML = html;
            },
            loadError: function (e) {
                var player = this.settings.createPlayer,
                    errorMessage = getByClass(player.errorMessageClass, this.wrapper);
                container[audiojs].helpers.removeClass(this.wrapper, player.loadingClass);
                container[audiojs].helpers.addClass(this.wrapper, player.errorClass);
                errorMessage.innerHTML = 'Error loading: "' + this.mp3 + '"';
            },
            init: function () {
                var player = this.settings.createPlayer;
                container[audiojs].helpers.addClass(this.wrapper, player.loadingClass);
            },
            loadStarted: function () {
                var player = this.settings.createPlayer,
                    duration = getByClass(player.durationClass, this.wrapper),
                    m = Math.floor(this.duration / 60),
                    s = Math.floor(this.duration % 60);
                container[audiojs].helpers.removeClass(this.wrapper, player.loadingClass);
                duration.innerHTML = ((m < 10 ? '0' : '') + m + ':' + (s < 10 ? '0' : '') + s);
            },
            loadProgress: function (percent) {
                var player = this.settings.createPlayer,
                    loaded = getByClass(player.loaderClass, this.wrapper);
                loaded.style.width = (100 * percent) + '%';
            },
            playPause: function () {
                if (this.playing) this.settings.play();
                else this.settings.pause();
            },
            play: function () {
                var player = this.settings.createPlayer;
                container[audiojs].helpers.addClass(this.wrapper, player.playingClass);
            },
            pause: function () {
                var player = this.settings.createPlayer;
                container[audiojs].helpers.removeClass(this.wrapper, player.playingClass);
            },
            updatePlayhead: function (percent) {
                var player = this.settings.createPlayer,
                    progress = getByClass(player.progressClass, this.wrapper);
                progress.style.width = (100 * percent) + '%';

                var played = getByClass(player.playedClass, this.wrapper),
                    p = this.duration * percent,
                    m = Math.floor(p / 60),
                    s = Math.floor(p % 60);
                played.innerHTML = ((m < 10 ? '0' : '') + m + ':' + (s < 10 ? '0' : '') + s);
            }
        },

        // ### Contructor functions
        // create()
        // Used to create a single audiojs instance.
        // If an array is passed then it calls back to createAll().
        // Otherwise, it creates a single instance and returns it.
        create: function (element, options) {
            var options = options || {}
            if (element.length) {
                return this.createAll(options, element);
            } else {
                return this.newInstance(element, options);
            }
        },

        // createAll()
        // Creates multiple audiojs instances.
        // If elements is null, then automatically find any <audio> tags on the page and create audiojs instances for them.
        createAll: function (options, elements) {
            var audioElements = elements || document.getElementsByTagName('audio'),
                instances = []
                options = options || {};
            for (var i = 0, ii = audioElements.length; i < ii; i++) {
                instances.push(this.newInstance(audioElements[i], options));
            }
            return instances;
        },

        // ### Creating and returning a new instance
        // This goes through all the steps required to build out a usable audiojs instance.
        newInstance: function (element, options) {
            var element = element,
                s = this.helpers.clone(this.settings),
                id = 'audiojs' + this.instanceCount,
                wrapperId = 'audiojs_wrapper' + this.instanceCount,
                instanceCount = this.instanceCount++;

            // Check for autoplay, loop and preload attributes and write them into the settings.
            if (element.getAttribute('autoplay') != null) s.autoplay = true;
            if (element.getAttribute('loop') != null) s.loop = true;
            if (element.getAttribute('preload') == 'none') s.preload = false;
            // Merge the default settings with the user-defined options.
            if (options) this.helpers.merge(s, options);

            // Inject the player html if required.
            if (s.createPlayer.markup) element = this.createPlayer(element, s.createPlayer, wrapperId);
            else element.parentNode.setAttribute('id', wrapperId);

            // Return a new audiojs instance.
            var audio = new container[audiojsInstance](element, s);

            // If css has been passed in, dynamically inject it into the <head>.
            if (s.css) this.helpers.injectCss(audio, s.css);

            // If <audio> or mp3 playback isn't supported, insert the swf & attach the required events for it.
            if (s.useFlash && s.hasFlash) {
                this.injectFlash(audio, id);
                this.attachFlashEvents(audio.wrapper, audio);
            } else if (s.useFlash && !s.hasFlash) {
                this.settings.flashError.apply(audio);
            }

            // Attach event callbacks to the new audiojs instance.
            if (!s.useFlash || (s.useFlash && s.hasFlash)) this.attachEvents(audio.wrapper, audio);

            // Store the newly-created audiojs instance.
            this.instances[id] = audio;
            return audio;
        },

        // ### Helper methods for constructing a working player
        // Inject a wrapping div and the markup for the html player.
        createPlayer: function (element, player, id) {
            var wrapper = document.createElement('div'),
                newElement = element.cloneNode(true);
            wrapper.setAttribute('class', 'audiojs');
            wrapper.setAttribute('className', 'audiojs');
            wrapper.setAttribute('id', id);

            // Fix IE's broken implementation of innerHTML & cloneNode for HTML5 elements.
            if (newElement.outerHTML && !document.createElement('audio').canPlayType) {
                newElement = this.helpers.cloneHtml5Node(element);
                wrapper.innerHTML = player.markup;
                wrapper.appendChild(newElement);
                element.outerHTML = wrapper.outerHTML;
                wrapper = document.getElementById(id);
            } else {
                wrapper.appendChild(newElement);
                wrapper.innerHTML = wrapper.innerHTML + player.markup;
                element.parentNode.replaceChild(wrapper, element);
            }
            return wrapper.getElementsByTagName('audio')[0];
        },

        // Attaches useful event callbacks to an audiojs instance.
        attachEvents: function (wrapper, audio) {
            if (!audio.settings.createPlayer) return;
            var player = audio.settings.createPlayer,
                playPause = getByClass(player.playPauseClass, wrapper),
                scrubber = getByClass(player.scrubberClass, wrapper),
                leftPos = function (elem) {
                    var curleft = 0;
                    if (elem.offsetParent) {
                        do {
                            curleft += elem.offsetLeft;
                        } while (elem = elem.offsetParent);
                    }
                    return curleft;
                };

            container[audiojs].events.addListener(playPause, 'click', function (e) {

                audio.playPause.apply(audio);
            });

            container[audiojs].events.addListener(scrubber, 'click', function (e) {
                var relativeLeft = e.clientX - leftPos(this);
                audio.skipTo(relativeLeft / scrubber.offsetWidth);
            });

            // _If flash is being used, then the following handlers don't need to be registered._
            if (audio.settings.useFlash) return;

            // Start tracking the load progress of the track.
            container[audiojs].events.trackLoadProgress(audio);

            container[audiojs].events.addListener(audio.element, 'timeupdate', function (e) {
                audio.updatePlayhead.apply(audio);
            });

            container[audiojs].events.addListener(audio.element, 'ended', function (e) {
                audio.trackEnded.apply(audio);
            });

            container[audiojs].events.addListener(audio.source, 'error', function (e) {
                // on error, cancel any load timers that are running.
                clearInterval(audio.readyTimer);
                clearInterval(audio.loadTimer);
                audio.settings.loadError.apply(audio);
            });

        },

        // Flash requires a slightly different API to the <audio> element, so this method is used to overwrite the standard event handlers.
        attachFlashEvents: function (element, audio) {
            audio['swfReady'] = false;
            audio['load'] = function (mp3) {
                // If the swf isn't ready yet then just set audio.mp3. init() will load it in once the swf is ready.
                audio.mp3 = mp3;
                if (audio.swfReady) audio.element.load(mp3);
            }
            audio['loadProgress'] = function (percent, duration) {
                audio.loadedPercent = percent;
                audio.duration = duration;
                audio.settings.loadStarted.apply(audio);
                audio.settings.loadProgress.apply(audio, [percent]);
            }
            audio['skipTo'] = function (percent) {
                if (percent > audio.loadedPercent) return;
                audio.updatePlayhead.call(audio, [percent])
                audio.element.skipTo(percent);
            }
            audio['updatePlayhead'] = function (percent) {
                audio.settings.updatePlayhead.apply(audio, [percent]);
            }
            audio['play'] = function () {
                // If the audio hasn't started preloading, then start it now.
                // Then set preload to true, so that any tracks loaded in subsequently are loaded straight away.
                if (!audio.settings.preload) {
                    audio.settings.preload = true;
                    audio.element.init(audio.mp3);
                }
                audio.playing = true;
                // IE doesn't allow a method named play() to be exposed through ExternalInterface, so lets go with pplay().
                // <http://dev.nuclearrooster.com/2008/07/27/externalinterfaceaddcallback-can-cause-ie-js-errors-with-certain-keyworkds/>
                audio.element.pplay();
                audio.settings.play.apply(audio);
            }
            audio['pause'] = function () {
                audio.playing = false;
                // Use ppause() for consistency with pplay(), even though it isn't really required.
                audio.element.ppause();
                audio.settings.pause.apply(audio);
            }
            audio['setVolume'] = function (v) {
                audio.element.setVolume(v);
            }
            audio['loadStarted'] = function () {
                // Load the mp3 specified by the audio element into the swf.
                audio.swfReady = true;
                if (audio.settings.preload) audio.element.init(audio.mp3);
                if (audio.settings.autoplay) audio.play.apply(audio);
            }
        },

        // ### Injecting an swf from a string
        // Build up the swf source by replacing the $keys and then inject the markup into the page.
        injectFlash: function (audio, id) {
            var flashSource = this.flashSource.replace(/\$1/g, id);
            flashSource = flashSource.replace(/\$2/g, audio.settings.swfLocation);
            // (+new Date) ensures the swf is not pulled out of cache. The fixes an issue with Firefox running multiple players on the same page.
            flashSource = flashSource.replace(/\$3/g, (+new Date + Math.random()));
            // Inject the player markup using a more verbose innerHTML insertion technique that works with IE.
            var html = audio.wrapper.innerHTML,
                div = document.createElement('div');
            div.innerHTML = flashSource + html;
            audio.wrapper.innerHTML = div.innerHTML;
            audio.element = this.helpers.getSwf(id);
        },

        // ## Helper functions
        helpers: {
            // **Merge two objects, with obj2 overwriting obj1**
            // The merge is shallow, but that's all that is required for our purposes.
            merge: function (obj1, obj2) {
                for (attr in obj2) {
                    if (obj1.hasOwnProperty(attr) || obj2.hasOwnProperty(attr)) {
                        obj1[attr] = obj2[attr];
                    }
                }
            },
            // **Clone a javascript object (recursively)**
            clone: function (obj) {
                if (obj == null || typeof(obj) !== 'object') return obj;
                var temp = new obj.constructor();
                for (var key in obj) temp[key] = arguments.callee(obj[key]);
                return temp;
            },
            // **Adding/removing classnames from elements**
            addClass: function (element, className) {
                var re = new RegExp('(\\s|^)' + className + '(\\s|$)');
                if (re.test(element.className)) return;
                element.className += ' ' + className;
            },
            removeClass: function (element, className) {
                var re = new RegExp('(\\s|^)' + className + '(\\s|$)');
                element.className = element.className.replace(re, ' ');
            },
            // **Dynamic CSS injection**
            // Takes a string of css, inserts it into a <style>, then injects it in at the very top of the <head>. This ensures any user-defined styles will take precedence.
            injectCss: function (audio, string) {

                // If an audiojs <style> tag already exists, then append to it rather than creating a whole new <style>.
                var prepend = '',
                    styles = document.getElementsByTagName('style'),
                    css = string.replace(/\$1/g, audio.settings.imageLocation);

                for (var i = 0, ii = styles.length; i < ii; i++) {
                    var title = styles[i].getAttribute('title');
                    if (title && ~title.indexOf('audiojs')) {
                        style = styles[i];
                        if (style.innerHTML === css) return;
                        prepend = style.innerHTML;
                        break;
                    }
                };

                var head = document.getElementsByTagName('head')[0],
                    firstchild = head.firstChild,
                    style = document.createElement('style');

                if (!head) return;

                style.setAttribute('type', 'text/css');
                style.setAttribute('title', 'audiojs');

                if (style.styleSheet) style.styleSheet.cssText = prepend + css;
                else style.appendChild(document.createTextNode(prepend + css));

                if (firstchild) head.insertBefore(style, firstchild);
                else head.appendChild(styleElement);
            },
            // **Handle all the IE6+7 requirements for cloning <audio> nodes**
            // Create a html5-safe document fragment by injecting an <audio> element into the document fragment.
            cloneHtml5Node: function (audioTag) {
                var fragment = document.createDocumentFragment(),
                    doc = fragment.createElement ? fragment : document;
                doc.createElement('audio');
                var div = doc.createElement('div');
                fragment.appendChild(div);
                div.innerHTML = audioTag.outerHTML;
                return div.firstChild;
            },
            // **Cross-browser <object> / <embed> element selection**
            getSwf: function (name) {
                var swf = document[name] || window[name];
                return swf.length > 1 ? swf[swf.length - 1] : swf;
            }
        },
        // ## Event-handling
        events: {
            memoryLeaking: false,
            listeners: [],
            // **A simple cross-browser event handler abstraction**
            addListener: function (element, eventName, func) {
                // For modern browsers use the standard DOM-compliant addEventListener.
                if (element.addEventListener) {
                    element.addEventListener(eventName, func, false);
                    // For older versions of Internet Explorer, use attachEvent.
                    // Also provide a fix for scoping this to the calling element and register each listener so the containing elements can be purged on page unload.
                } else if (element.attachEvent) {
                    this.listeners.push(element);
                    if (!this.memoryLeaking) {
                        window.attachEvent('onunload', function () {
                            if (this.listeners) {
                                for (var i = 0, ii = this.listeners.length; i < ii; i++) {
                                    container[audiojs].events.purge(this.listeners[i]);
                                }
                            }
                        });
                        this.memoryLeaking = true;
                    }
                    element.attachEvent('on' + eventName, function () {
                        func.call(element, window.event);
                    });
                }
            },

            trackLoadProgress: function (audio) {

                // If preload has been set to none, then we don't want to start loading the track yet.
                if (!audio.settings.preload) return;

                var readyTimer, loadTimer, audio = audio,
                    ios = (/(ipod|iphone|ipad)/i).test(navigator.userAgent);

                // Use timers here rather than the official progress event, as Chrome has issues calling progress when loading mp3 files from cache.
                readyTimer = setInterval(function () {
                    if (audio.element.readyState > -1) {
                        // iOS doesn't start preloading the mp3 until the user interacts manually, so this stops the loader being displayed prematurely.
                        if (!ios) audio.init.apply(audio);
                    }


                    if (audio.element.readyState > 1) {
                        if (audio.settings.autoplay) audio.play.apply(audio);
                        clearInterval(readyTimer);
                        // Once we have data, start tracking the load progress.
                        loadTimer = setInterval(function () {
                            audio.loadProgress.apply(audio);
                            if (audio.loadedPercent >= 1) clearInterval(loadTimer);
                        }, 200);
                    }

                }, 200);
                audio.readyTimer = readyTimer;
                audio.loadTimer = loadTimer;
            },

            // **Douglas Crockford's IE6 memory leak fix**
            // <http://javascript.crockford.com/memory/leak.html>
            // This is used to release the memory leak created by the circular references created when fixing this scoping for IE. It is called on page unload.
            purge: function (d) {
                var a = d.attributes,
                    i;
                if (a) {
                    for (i = 0; i < a.length; i += 1) {
                        if (typeof d[a[i].name] === 'function') d[a[i].name] = null;
                    }
                }
                a = d.childNodes;
                if (a) {
                    for (i = 0; i < a.length; i += 1) purge(d.childNodes[i]);
                }
            },

            // **DOMready function**
            // As seen here: <https://github.com/dperini/ContentLoaded/>.
            ready: (function () {
                return function (fn) {
                    var win = window,
                        done = false,
                        top = true,
                        doc = win.document,
                        root = doc.documentElement,
                        add = doc.addEventListener ? 'addEventListener' : 'attachEvent',
                        rem = doc.addEventListener ? 'removeEventListener' : 'detachEvent',
                        pre = doc.addEventListener ? '' : 'on',
                        init = function (e) {
                            if (e.type == 'readystatechange' && doc.readyState != 'complete') return;
                            (e.type == 'load' ? win : doc)[rem](pre + e.type, init, false);
                            if (!done && (done = true)) fn.call(win, e.type || e);
                        },
                        poll = function () {
                            try {
                                root.doScroll('left');
                            } catch (e) {
                                setTimeout(poll, 50);
                                return;
                            }
                            init('poll');
                        };
                    if (doc.readyState == 'complete') fn.call(win, 'lazy');
                    else {
                        if (doc.createEventObject && root.doScroll) {
                            try {
                                top = !win.frameElement;
                            } catch (e) {}
                            if (top) poll();
                        }
                        doc[add](pre + 'DOMContentLoaded', init, false);
                        doc[add](pre + 'readystatechange', init, false);
                        win[add](pre + 'load', init, false);
                    }
                }
            })()

        }
    }

    // ## The audiojs class
    // We create one of these per <audio> and then push them into audiojs['instances'].
    container[audiojsInstance] = function (element, settings) {
        // Each audio instance returns an object which contains an API back into the <audio> element.
        this.element = element;
        this.wrapper = element.parentNode;
        this.source = element.getElementsByTagName('source')[0] || element;
        // First check the <audio> element directly for a src and if one is not found, look for a <source> element.
        this.mp3 = (function (element) {
            var source = element.getElementsByTagName('source')[0];
            return element.getAttribute('src') || (source ? source.getAttribute('src') : null);
        })(element);
        this.settings = settings;
        this.loadStartedCalled = false;
        this.loadedPercent = 0;
        this.duration = 1;
        this.playing = false;
    }

    container[audiojsInstance].prototype = {
        // API access events:
        // Each of these do what they need do and then call the matching methods defined in the settings object.
        updatePlayhead: function () {
            var percent = this.element.currentTime / this.duration;
            this.settings.updatePlayhead.apply(this, [percent]);
        },
        skipTo: function (percent) {
            if (percent > this.loadedPercent) return;
            this.element.currentTime = this.duration * percent;
            this.updatePlayhead();
        },
        load: function (mp3) {
            this.loadStartedCalled = false;
            this.source.setAttribute('src', mp3);
            // The now outdated load() method is required for Safari 4
            this.element.load();
            this.mp3 = mp3;
            container[audiojs].events.trackLoadProgress(this);
        },
        loadError: function () {
            this.settings.loadError.apply(this);
        },
        init: function () {
            this.settings.init.apply(this);
        },
        loadStarted: function () {
            // Wait until element.duration exists before setting up the audio player.
            if (!this.element.duration) return false;

            this.duration = this.element.duration;
            this.updatePlayhead();
            this.settings.loadStarted.apply(this);
        },
        loadProgress: function () {
            if (this.element.buffered != null && this.element.buffered.length) {
                // Ensure loadStarted() is only called once.
                if (!this.loadStartedCalled) {
                    this.loadStartedCalled = this.loadStarted();
                }
                var durationLoaded = this.element.buffered.end(this.element.buffered.length - 1);
                this.loadedPercent = durationLoaded / this.duration;

                this.settings.loadProgress.apply(this, [this.loadedPercent]);

                return true
            }
        },
        playPause: function () {
            if (this.playing) this.pause();
            else this.play();
        },
        play: function () {
            var ios = (/(ipod|iphone|ipad)/i).test(navigator.userAgent);
            // On iOS this interaction will trigger loading the mp3, so run init().
            if (ios && this.element.readyState == 0) this.init.apply(this);
            // If the audio hasn't started preloading, then start it now.
            // Then set preload to true, so that any tracks loaded in subsequently are loaded straight away.
            if (!this.settings.preload) {
                this.settings.preload = true;
                this.element.setAttribute('preload', 'auto');
                container[audiojs].events.trackLoadProgress(this);
            }
            this.playing = true;
            this.element.play();
            this.settings.play.apply(this);
        },
        pause: function () {
            this.playing = false;
            this.element.pause();
            this.settings.pause.apply(this);
        },
        setVolume: function (v) {
            this.element.volume = v;
        },
        trackEnded: function (e) {
            this.skipTo.apply(this, [0]);
            if (!this.settings.loop) this.pause.apply(this);
            this.settings.trackEnded.apply(this);
        }
    }

    // **getElementsByClassName**
    // Having to rely on getElementsByTagName is pretty inflexible internally, so a modified version of Dustin Diaz's getElementsByClassName has been included.
    // This version cleans things up and prefers the native DOM method if it's available.
    var getByClass = function (searchClass, node) {
        var matches = [];
        node = node || document;

        if (node.getElementsByClassName) {
            matches = node.getElementsByClassName(searchClass);
        } else {
            var i, l, els = node.getElementsByTagName("*"),
                pattern = new RegExp("(^|\\s)" + searchClass + "(\\s|$)");

            for (i = 0, l = els.length; i < l; i++) {
                if (pattern.test(els[i].className)) {
                    matches.push(els[i]);
                }
            }
        }
        return matches.length > 1 ? matches : matches[0];
    };
    // The global variable names are passed in here and can be changed if they conflict with anything else.
})('audiojs', 'audiojsInstance', this);


/*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.3.6
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */

/* global window, document, define, jQuery, setInterval, clearInterval */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else {
        factory(jQuery);
    }

}(function ($) {
    'use strict';
    var Slick = window.Slick || {};

    Slick = (function () {

        var instanceUid = 0;

        function Slick(element, settings) {

            var _ = this,
                responsiveSettings, breakpoint;

            _.defaults = {
                accessibility: true,
                appendArrows: $(element),
                arrows: true,
                asNavFor: null,
                prevArrow: '<button type="button" class="slick-prev">Previous</button>',
                nextArrow: '<button type="button" class="slick-next">Next</button>',
                autoplay: false,
                autoplaySpeed: 3000,
                centerMode: false,
                centerPadding: '50px',
                cssEase: 'ease',
                customPaging: function (slider, i) {
                    return '<div class="icon">' + (i + 1) + '</div>';
                },
                dots: false,
                dotsClass: 'slider-dots',
                draggable: true,
                easing: 'linear',
                fade: false,
                focusOnSelect: false,
                infinite: true,
                lazyLoad: 'ondemand',
                onBeforeChange: null,
                onAfterChange: null,
                onInit: null,
                onReInit: null,
                pauseOnHover: true,
                pauseOnDotsHover: false,
                responsive: null,
                slide: 'div',
                slidesToShow: 1,
                slidesToScroll: 1,
                showTitles: true,
                speed: 300,
                swipe: true,
                touchMove: true,
                touchThreshold: 5,
                useCSS: true,
                vertical: false
            };

            _.initials = {
                animating: false,
                dragging: false,
                autoPlayTimer: null,
                currentSlide: 0,
                currentLeft: null,
                direction: 1,
                $dots: null,
                listWidth: null,
                listHeight: null,
                loadIndex: 0,
                $nextArrow: null,
                $prevArrow: null,
                slideCount: null,
                slideWidth: null,
                $slideTrack: null,
                $slides: null,
                sliding: false,
                slideOffset: 0,
                swipeLeft: null,
                $list: null,
                touchObject: {},
                transformsEnabled: false
            };

            $.extend(_, _.initials);

            _.activeBreakpoint = null;
            _.animType = null;
            _.animProp = null;
            _.breakpoints = [];
            _.breakpointSettings = [];
            _.cssTransitions = false;
            _.paused = false;
            _.positionProp = null;
            _.$slider = $(element);
            _.$slidesCache = null;
            _.transformType = null;
            _.transitionType = null;
            _.windowWidth = 0;
            _.windowTimer = null;

            _.options = $.extend({}, _.defaults, settings);

            _.originalSettings = _.options;
            responsiveSettings = _.options.responsive || null;

            if (responsiveSettings && responsiveSettings.length > -1) {
                for (breakpoint in responsiveSettings) {
                    if (responsiveSettings.hasOwnProperty(breakpoint)) {
                        _.breakpoints.push(responsiveSettings[
                        breakpoint].breakpoint);
                        _.breakpointSettings[responsiveSettings[
                        breakpoint].breakpoint] =
                        responsiveSettings[breakpoint].settings;
                    }
                }
                _.breakpoints.sort(function (a, b) {
                    return b - a;
                });
            }

            _.autoPlay = $.proxy(_.autoPlay, _);
            _.autoPlayClear = $.proxy(_.autoPlayClear, _);
            _.changeSlide = $.proxy(_.changeSlide, _);
            _.selectHandler = $.proxy(_.selectHandler, _);
            _.setPosition = $.proxy(_.setPosition, _);
            _.swipeHandler = $.proxy(_.swipeHandler, _);
            _.dragHandler = $.proxy(_.dragHandler, _);
            _.keyHandler = $.proxy(_.keyHandler, _);
            _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);

            _.instanceUid = instanceUid++;

            // A simple way to check for HTML strings
            // Strict HTML recognition (must start with <)
            // Extracted from jQuery v1.11 source
            _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;

            _.init();

        }

        return Slick;

    }());

    Slick.prototype.addSlide = function (markup, index, addBefore) {

        var _ = this;

        if (typeof(index) === 'boolean') {
            addBefore = index;
            index = null;
        } else if (index < 0 || (index >= _.slideCount)) {
            return false;
        }

        _.unload();

        if (typeof(index) === 'number') {
            if (index === 0 && _.$slides.length === 0) {
                $(markup).appendTo(_.$slideTrack);
            } else if (addBefore) {
                $(markup).insertBefore(_.$slides.eq(index));
            } else {
                $(markup).insertAfter(_.$slides.eq(index));
            }
        } else {
            if (addBefore === true) {
                $(markup).prependTo(_.$slideTrack);
            } else {
                $(markup).appendTo(_.$slideTrack);
            }
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).remove();

        _.$slideTrack.append(_.$slides);

        _.$slides.each(function (index, element) {
            $(element).attr("index", index);
        });

        _.$slidesCache = _.$slides;

        _.reinit();

    };

    Slick.prototype.animateSlide = function (targetLeft, callback) {

        var animProps = {},
            _ = this;

        if (_.transformsEnabled === false) {
            if (_.options.vertical === false) {
                _.$slideTrack.animate({
                    left: targetLeft
                }, _.options.speed, _.options.easing, callback);
            } else {
                _.$slideTrack.animate({
                    top: targetLeft
                }, _.options.speed, _.options.easing, callback);
            }

        } else {

            if (_.cssTransitions === false) {

                $({
                    animStart: _.currentLeft
                }).animate({
                    animStart: targetLeft
                }, {
                    duration: _.options.speed,
                    easing: _.options.easing,
                    step: function (now) {
                        if (_.options.vertical === false) {
                            animProps[_.animType] = 'translate(' + now + 'px, 0px)';
                            _.$slideTrack.css(animProps);
                        } else {
                            animProps[_.animType] = 'translate(0px,' + now + 'px)';
                            _.$slideTrack.css(animProps);
                        }
                    },
                    complete: function () {
                        if (callback) {
                            callback.call();
                        }
                    }
                });

            } else {

                _.applyTransition();

                if (_.options.vertical === false) {
                    animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';
                } else {
                    animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';
                }
                _.$slideTrack.css(animProps);

                if (callback) {
                    setTimeout(function () {

                        _.disableTransition();

                        callback.call();
                    }, _.options.speed);
                }

            }

        }

    };

    Slick.prototype.applyTransition = function (slide) {

        var _ = this,
            transition = {};

        if (_.options.fade === false) {
            transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;
        } else {
            transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;
        }

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }

    };

    Slick.prototype.autoPlay = function () {

        var _ = this;

        if (_.autoPlayTimer) {
            clearInterval(_.autoPlayTimer);
        }

        // if (_.slideCount > _.options.slidesToShow && _.paused !== true) {
        if (_.paused !== true) {
            _.autoPlayTimer = setInterval(_.autoPlayIterator, _.options.autoplaySpeed);
        }

    };

    Slick.prototype.autoPlayClear = function () {

        var _ = this;

        if (_.autoPlayTimer) {
            clearInterval(_.autoPlayTimer);
        }

    };

    Slick.prototype.autoPlayIterator = function () {

        var _ = this;

        if (_.options.infinite === false) {

            if (_.direction === 1) {

                if ((_.currentSlide + 1) === _.slideCount - 1) {
                    _.direction = 0;
                }

                _.slideHandler(_.currentSlide + _.options.slidesToScroll);

            } else {

                if ((_.currentSlide - 1 === 0)) {

                    _.direction = 1;

                }

                _.slideHandler(_.currentSlide - _.options.slidesToScroll);

            }

        } else {

            _.slideHandler(_.currentSlide + _.options.slidesToScroll);

        }

    };

    Slick.prototype.buildNav = function () {

        var _ = this

        if (_.options.showTitles === true) {

            _.$navContainer = $('<div class="slider__nav-container" ></div>').appendTo(
            _.$slider);

        }

    }

    Slick.prototype.buildArrows = function () {

        var _ = this;

        // if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
        if (_.options.arrows === true) {
            if (_.options.showTitles === true) {

                _.$arrowContainer = $('<div class="slider__nav--arrows tiles tiles--light tiles--horizontal"></div>').appendTo(
                _.$navContainer);


            } else {
                _.$arrowContainer = $('<div class="slider__nav--arrows tiles  "></div>').appendTo(
                _.$slider);
            }

            _.$prevArrow = $('<div class="tile__item icon icon--small icon--arrow-left slider__nav--prev"></div>').appendTo(
            _.$arrowContainer);
            _.$nextArrow = $('<div class="tile__item icon icon--small icon--arrow-right slider__nav--next"></div>').appendTo(
            _.$arrowContainer);

            if (_.options.infinite !== true) {
                _.$prevArrow.addClass('slick-disabled');
            }

        }

    };

    Slick.prototype.buildDots = function () {

        var _ = this,
            i, dotString;

        // if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
        if (_.options.dots === true) {

            dotString = '<ul class="slider__nav">';

            for (i = 0; i <= _.getDotCount(); i += 1) {
                dotString += '<li>' + _.options.customPaging.call(this, _, i) + '</li>';
            }

            dotString += '</ul>';

            if (_.options.showTitles === false) {
                _.$dots = $(dotString).appendTo(
                _.$navContainer);
            } else {
                _.$dots = $(dotString).appendTo(
                _.$slider);
            }


            _.$dots.find('li').first().addClass('slider--active');

        }

    };

    Slick.prototype.buildOut = function () {

        var _ = this;

        _.$slides = _.$slider.children(_.options.slide + ':not(.slider--cloned)').addClass('slider__item');
        _.slideCount = _.$slides.length;
        _.$slidesCache = _.$slides;

        _.$slider.addClass('slider');

        _.$slideTrack = (_.slideCount === 0) ? $('<div class="slider__track"/>').appendTo(_.$slider) : _.$slides.wrapAll('<div class="slider__track"/>').parent();

        _.$list = _.$slideTrack.wrap('<div class="slider__list"/>').parent();
        _.$slideTrack.css('opacity', 0);

        if (_.options.centerMode === true) {
            _.options.infinite = true;
            _.options.slidesToScroll = 1;
            if (_.options.slidesToShow % 2 === 0) {
                _.options.slidesToShow = 3;
            }
        }

        $('img[data-lazy]', _.$slider).not('[src]').addClass('slider--loading');

        _.setupInfinite();

        _.buildNav();

        _.buildDots();

        _.buildArrows();

        if (_.options.accessibility === true) {
            _.$list.prop('tabIndex', 0);
        }

        _.setSlideClasses(typeof this.currentSlide === 'number' ? this.currentSlide : 0);

        if (_.options.draggable === true) {
            _.$list.addClass('draggable');
        }

    };

    Slick.prototype.checkResponsive = function () {

        var _ = this,
            breakpoint, targetBreakpoint;

        if (_.originalSettings.responsive && _.originalSettings.responsive.length > -1 && _.originalSettings.responsive !== null) {

            targetBreakpoint = null;

            for (breakpoint in _.breakpoints) {
                if (_.breakpoints.hasOwnProperty(breakpoint)) {
                    if ($(window).width() < _.breakpoints[
                    breakpoint]) {
                        targetBreakpoint = _.breakpoints[
                        breakpoint];
                    }
                }
            }

            if (targetBreakpoint !== null) {
                if (_.activeBreakpoint !== null) {
                    if (targetBreakpoint !== _.activeBreakpoint) {
                        _.activeBreakpoint =
                        targetBreakpoint;
                        _.options = $.extend({}, _.defaults, _.breakpointSettings[
                        targetBreakpoint]);
                        _.refresh();
                    }
                } else {
                    _.activeBreakpoint = targetBreakpoint;
                    _.options = $.extend({}, _.defaults, _.breakpointSettings[
                    targetBreakpoint]);
                    _.refresh();
                }
            } else {
                if (_.activeBreakpoint !== null) {
                    _.activeBreakpoint = null;
                    _.options = $.extend({}, _.defaults, _.originalSettings);
                    _.refresh();
                }
            }

        }

    };

    Slick.prototype.changeSlide = function (event) {

        var _ = this,
            $target = $(event.target);
        var asNavFor = _.options.asNavFor != null ? $(_.options.asNavFor).getSlick() : null;

        // If target is a link, prevent default action.
        $target.is('a') && event.preventDefault();

        switch (event.data.message) {

        case 'previous':
            // if (_.slideCount > _.options.slidesToShow) {
            _.slideHandler(_.currentSlide - _.options.slidesToScroll);
            if (asNavFor != null) asNavFor.slideHandler(asNavFor.currentSlide - asNavFor.options.slidesToScroll);
            // }
            break;

        case 'next':
            // if (_.slideCount > _.options.slidesToShow) {
            _.slideHandler(_.currentSlide + _.options.slidesToScroll);
            if (asNavFor != null) asNavFor.slideHandler(asNavFor.currentSlide + asNavFor.options.slidesToScroll);
            // }
            break;

        case 'index':
            var index = $(event.target).parent().index() * _.options.slidesToScroll;
            _.slideHandler(index);
            if (asNavFor != null) asNavFor.slideHandler(index);
            break;

        default:
            return false;
        }

    };

    Slick.prototype.destroy = function () {

        var _ = this;

        _.autoPlayClear();

        _.touchObject = {};

        $('.slider--cloned', _.$slider).remove();
        if (_.$dots) {
            _.$dots.remove();
        }
        if (_.$prevArrow) {
            _.$prevArrow.remove();
            _.$nextArrow.remove();
        }
        _.$slides.unwrap().unwrap();
        _.$slides.removeClass('slider__item slider__item--active slider__item--visible').removeAttr('style');
        _.$slider.removeClass('slider');
        _.$slider.removeClass('slider--initialized');

        _.$list.off('.slick');
        $(window).off('.slick-' + _.instanceUid);
    };

    Slick.prototype.disableTransition = function (slide) {

        var _ = this,
            transition = {};

        transition[_.transitionType] = "";

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }

    };

    Slick.prototype.fadeSlide = function (slideIndex, callback) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).css({
                zIndex: 1000
            });

            _.$slides.eq(slideIndex).animate({
                opacity: 1
            }, _.options.speed, _.options.easing, callback);

        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 1,
                zIndex: 1000
            });

            if (callback) {
                setTimeout(function () {

                    _.disableTransition(slideIndex);

                    callback.call();
                }, _.options.speed);
            }

        }

    };

    Slick.prototype.filterSlides = function (filter) {

        var _ = this;

        if (filter !== null) {

            _.unload();

            _.$slideTrack.children(this.options.slide).remove();

            _.$slidesCache.filter(filter).appendTo(_.$slideTrack);

            _.reinit();

        }

    };

    Slick.prototype.getCurrent = function () {

        var _ = this;

        return _.currentSlide;

    };

    Slick.prototype.getDotCount = function () {

        var _ = this,
            breaker = 0,
            dotCounter = 0,
            dotCount = 0,
            dotLimit;

        dotLimit = _.options.infinite === true ? _.slideCount + _.options.slidesToShow - _.options.slidesToScroll : _.slideCount;

        while (breaker < dotLimit) {
            dotCount++;
            dotCounter += _.options.slidesToScroll;
            breaker = dotCounter + _.options.slidesToShow;
        }

        return dotCount;

    };

    Slick.prototype.getLeft = function (slideIndex) {

        var _ = this,
            targetLeft, verticalHeight, verticalOffset = 0;

        _.slideOffset = 0;
        verticalHeight = _.$slides.first().outerHeight();

        if (_.options.infinite === true) {
            // if (_.slideCount > _.options.slidesToShow) {
            _.slideOffset = (_.slideWidth * _.options.slidesToShow) * -1;
            verticalOffset = (verticalHeight * _.options.slidesToShow) * -1;
            // }
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                // if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
                if (slideIndex + _.options.slidesToScroll > _.slideCount) {
                    _.slideOffset = ((_.slideCount % _.options.slidesToShow) * _.slideWidth) * -1;
                    verticalOffset = ((_.slideCount % _.options.slidesToShow) * verticalHeight) * -1;
                }
            }
        } else {
            if (_.slideCount % _.options.slidesToShow !== 0) {
                // if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
                if (slideIndex + _.options.slidesToScroll > _.slideCount) {
                    _.slideOffset = (_.options.slidesToShow * _.slideWidth) - ((_.slideCount % _.options.slidesToShow) * _.slideWidth);
                    verticalOffset = ((_.slideCount % _.options.slidesToShow) * verticalHeight);
                }
            }
        }

        if (_.options.centerMode === true && _.options.infinite === true) {
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
        } else if (_.options.centerMode === true) {
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
        }

        if (_.options.vertical === false) {
            if (_.slideCount === 3) {
                targetLeft = (((slideIndex - 1) * _.slideWidth) * -1) + _.slideOffset;
            } else {
                targetLeft = ((slideIndex * _.slideWidth) * -1) + _.slideOffset;
            }
        } else {
            targetLeft = ((slideIndex * verticalHeight) * -1) + verticalOffset;
        }

        return targetLeft;

    };

    Slick.prototype.init = function () {

        var _ = this;

        if (!$(_.$slider).hasClass('slider--initialized')) {

            $(_.$slider).addClass('slider--initialized');
            _.buildOut();
            _.setProps();
            _.startLoad();
            _.loadSlider();
            _.initializeEvents();
            _.checkResponsive();
        }

        if (_.options.onInit !== null) {
            _.options.onInit.call(this, _);
        }

    };

    Slick.prototype.initArrowEvents = function () {

        var _ = this;

        // if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
        if (_.options.arrows === true) {
            _.$prevArrow.on('click.slick', {
                message: 'previous'
            }, _.changeSlide);
            _.$nextArrow.on('click.slick', {
                message: 'next'
            }, _.changeSlide);
        }

    };

    Slick.prototype.initDotEvents = function () {

        var _ = this;

        // if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
        if (_.options.dots === true) {
            $('li', _.$dots).on('click.slick', {
                message: 'index'
            }, _.changeSlide);
        }

    };

    Slick.prototype.initializeEvents = function () {

        var _ = this;

        _.initArrowEvents();

        _.initDotEvents();

        _.$list.on('touchstart.slick mousedown.slick', {
            action: 'start'
        }, _.swipeHandler);
        _.$list.on('touchmove.slick mousemove.slick', {
            action: 'move'
        }, _.swipeHandler);
        _.$list.on('touchend.slick mouseup.slick', {
            action: 'end'
        }, _.swipeHandler);
        _.$list.on('touchcancel.slick mouseleave.slick', {
            action: 'end'
        }, _.swipeHandler);

        if (_.options.pauseOnHover === true && _.options.autoplay === true) {
            _.$list.on('mouseenter.slick', _.autoPlayClear);
            _.$list.on('mouseleave.slick', _.autoPlay);
        }

        if (_.options.accessibility === true) {
            _.$list.on('keydown.slick', _.keyHandler);
        }

        $(window).on('orientationchange.slick.slick-' + _.instanceUid, function () {
            _.checkResponsive();
            _.setPosition();
        });

        $(window).on('resize.slick.slick-' + _.instanceUid, function () {
            if ($(window).width !== _.windowWidth) {
                clearTimeout(_.windowDelay);
                _.windowDelay = window.setTimeout(function () {
                    _.windowWidth = $(window).width();
                    _.checkResponsive();
                    _.setPosition();
                }, 50);
            }
        });

        $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
        $(document).on('ready.slick.slick-' + _.instanceUid, _.setPosition);

    };

    Slick.prototype.initUI = function () {

        var _ = this;

        // if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
        if (_.options.arrows === true) {

            _.$prevArrow.show();
            _.$nextArrow.show();

        }

        // if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
        if (_.options.dots === true) {

            _.$dots.show();

        }

        if (_.options.autoplay === true) {

            _.autoPlay();

        }

    };

    Slick.prototype.keyHandler = function (event) {

        var _ = this;

        if (event.keyCode === 37) {
            _.changeSlide({
                data: {
                    message: 'previous'
                }
            });
        } else if (event.keyCode === 39) {
            _.changeSlide({
                data: {
                    message: 'next'
                }
            });
        }

    };

    Slick.prototype.lazyLoad = function () {

        var _ = this,
            loadRange, cloneRange, rangeStart, rangeEnd;

        if (_.options.centerMode === true || _.options.fade === true) {
            rangeStart = _.options.slidesToShow + _.currentSlide - 1;
            rangeEnd = rangeStart + _.options.slidesToShow + 2;
        } else {
            rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
            rangeEnd = rangeStart + _.options.slidesToShow;
        }

        loadRange = _.$slider.find('.slider__item').slice(rangeStart, rangeEnd);

        $('img[data-lazy]', loadRange).not('[src]').each(function () {
            $(this).css({
                opacity: 0
            }).attr('src', $(this).attr('data-lazy')).removeClass('slider--loading').load(function () {
                $(this).animate({
                    opacity: 1
                }, 200);
            });
        });

        if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slider--cloned').slice(0, _.options.slidesToShow);
            $('img[data-lazy]', cloneRange).not('[src]').each(function () {
                $(this).css({
                    opacity: 0
                }).attr('src', $(this).attr('data-lazy')).removeClass('slider--loading').load(function () {
                    $(this).animate({
                        opacity: 1
                    }, 200);
                });
            });
        } else if (_.currentSlide === 0) {
            cloneRange = _.$slider.find('.slider--cloned').slice(_.options.slidesToShow * -1);
            $('img[data-lazy]', cloneRange).not('[src]').each(function () {
                $(this).css({
                    opacity: 0
                }).attr('src', $(this).attr('data-lazy')).removeClass('slider--loading').load(function () {
                    $(this).animate({
                        opacity: 1
                    }, 200);
                });
            });
        }

    };

    Slick.prototype.loadSlider = function () {

        var _ = this;

        _.setPosition();

        _.$slideTrack.css({
            opacity: 1
        });

        _.$slider.removeClass('slider--loading');

        _.initUI();

        if (_.options.lazyLoad === 'progressive') {
            _.progressiveLazyLoad();
        }

    };

    Slick.prototype.postSlide = function (index) {

        var _ = this;

        if (_.options.onAfterChange !== null) {
            _.options.onAfterChange.call(this, _, index);
        }

        _.animating = false;

        _.setPosition();

        _.swipeLeft = null;

        if (_.options.autoplay === true && _.paused === false) {
            _.autoPlay();
        }

    };

    Slick.prototype.progressiveLazyLoad = function () {

        var _ = this,
            imgCount, targetImage;

        imgCount = $('img[data-lazy]').not('[src]').length;

        if (imgCount > 0) {
            targetImage = $($('img[data-lazy]', _.$slider).not('[src]').get(0));
            targetImage.attr('src', targetImage.attr('data-lazy')).removeClass('slider--loading').load(function () {
                _.progressiveLazyLoad();
            });
        }

    };

    Slick.prototype.refresh = function () {

        var _ = this,
            currentSlide = _.currentSlide;

        _.destroy();

        $.extend(_, _.initials);

        _.currentSlide = currentSlide;
        _.init();

    };

    Slick.prototype.reinit = function () {

        var _ = this;

        _.$slides = _.$slideTrack.children(_.options.slide).addClass('slider__item');

        _.slideCount = _.$slides.length;

        if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
            _.currentSlide = _.currentSlide - _.options.slidesToScroll;
        }

        _.setProps();

        _.setupInfinite();

        _.buildArrows();

        _.updateArrows();

        _.initArrowEvents();

        _.buildDots();

        _.updateDots();

        _.initDotEvents();

        _.setSlideClasses(0);

        _.setPosition();

        if (_.options.onReInit !== null) {
            _.options.onReInit.call(this, _);
        }

    };

    Slick.prototype.removeSlide = function (index, removeBefore) {

        var _ = this;

        if (typeof(index) === 'boolean') {
            removeBefore = index;
            index = removeBefore === true ? 0 : _.slideCount - 1;
        } else {
            index = removeBefore === true ? --index : index;
        }

        if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
            return false;
        }

        _.unload();

        _.$slideTrack.children(this.options.slide).eq(index).remove();

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).remove();

        _.$slideTrack.append(_.$slides);

        _.$slidesCache = _.$slides;

        _.reinit();

    };

    Slick.prototype.setCSS = function (position) {

        var _ = this,
            positionProps = {},
            x, y;

        x = _.positionProp == 'left' ? position + 'px' : '0px';
        y = _.positionProp == 'top' ? position + 'px' : '0px';

        positionProps[_.positionProp] = position;

        if (_.transformsEnabled === false) {
            _.$slideTrack.css(positionProps);
        } else {
            positionProps = {};
            if (_.cssTransitions === false) {
                positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';
                _.$slideTrack.css(positionProps);
            } else {
                positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';
                _.$slideTrack.css(positionProps);
            }
        }

    };

    Slick.prototype.setDimensions = function () {

        var _ = this;

        if (_.options.centerMode === true) {
            _.$slideTrack.children('.slider__item').width(_.slideWidth);
        } else {
            _.$slideTrack.children('.slider__item').width(_.slideWidth);
        }


        if (_.options.vertical === false) {
            _.$slideTrack.width(Math.ceil((_.slideWidth * _.$slideTrack.children('.slider__item').length)));
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: ('0px ' + _.options.centerPadding)
                });
            }
        } else {
            _.$list.height(_.$slides.first().outerHeight() * _.options.slidesToShow);
            _.$slideTrack.height(Math.ceil((_.$slides.first().outerHeight() * _.$slideTrack.children('.slider__item').length)));
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: (_.options.centerPadding + ' 0px')
                });
            }
        }

    };

    Slick.prototype.setFade = function () {

        var _ = this,
            targetLeft;

        _.$slides.each(function (index, element) {
            targetLeft = (_.slideWidth * index) * -1;
            $(element).css({
                position: 'relative',
                left: targetLeft,
                top: 0,
                zIndex: 800,
                opacity: 0
            });
        });

        _.$slides.eq(_.currentSlide).css({
            zIndex: 900,
            opacity: 1
        });

    };

    Slick.prototype.setPosition = function () {

        var _ = this;

        _.setValues();
        _.setDimensions();

        if (_.options.fade === false) {
            _.setCSS(_.getLeft(_.currentSlide));
        } else {
            _.setFade();
        }

    };

    Slick.prototype.setProps = function () {

        var _ = this;

        _.positionProp = _.options.vertical === true ? 'top' : 'left';

        if (_.positionProp === 'top') {
            _.$slider.addClass('slick-vertical');
        } else {
            _.$slider.removeClass('slick-vertical');
        }

        if (document.body.style.WebkitTransition !== undefined || document.body.style.MozTransition !== undefined || document.body.style.msTransition !== undefined) {
            if (_.options.useCSS === true) {
                _.cssTransitions = true;
            }
        }

        if (document.body.style.MozTransform !== undefined) {
            _.animType = 'MozTransform';
            _.transformType = "-moz-transform";
            _.transitionType = 'MozTransition';
        }
        if (document.body.style.webkitTransform !== undefined) {
            _.animType = 'webkitTransform';
            _.transformType = "-webkit-transform";
            _.transitionType = 'webkitTransition';
        }
        if (document.body.style.msTransform !== undefined) {
            _.animType = 'transform';
            _.transformType = "transform";
            _.transitionType = 'transition';
        }

        _.transformsEnabled = (_.animType !== null);

    };

    Slick.prototype.setValues = function () {

        var _ = this;

        _.listWidth = _.$list.width();
        _.listHeight = _.$list.height();
        if (_.options.vertical === false) {
            _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);

        } else {
            _.slideWidth = Math.ceil(_.listWidth);
        }

    };

    Slick.prototype.setSlideClasses = function (index) {

        var _ = this,
            centerOffset, allSlides, indexOffset;

        _.$slider.find('.slider__item').removeClass('slider__item--active').removeClass('slider__item--center');
        allSlides = _.$slider.find('.slider__item');

        if (_.options.centerMode === true) {

            centerOffset = Math.floor(_.options.slidesToShow / 2);

            if (_.slideCount <= 3) {
                if (_.slideCount < 3) {
                    indexOffset = _.slideCount + index;
                    allSlides.slice(indexOffset - centerOffset, indexOffset + centerOffset).addClass('slider__item--active');
                }
                else {
                    indexOffset = _.options.slidesToShow + index;
                    allSlides.slice(indexOffset - centerOffset, indexOffset + centerOffset + 1).addClass('slider__item--active');
                }
                if (_.slideCount == 3) {
                    allSlides.eq(index + 3).addClass('slider__item--center');
                }
                else {
                    allSlides.eq(index + 4).addClass('slider__item--center');
                }
            }
            else {
                if (index >= centerOffset && index <= (_.slideCount - 1) - centerOffset) {
                    _.$slides.slice(index - centerOffset, index + centerOffset + 1).addClass('slider__item--active');
                } else {
                    indexOffset = _.options.slidesToShow + index;
                    allSlides.slice(indexOffset - centerOffset + 1, indexOffset + centerOffset + 2).addClass('slider__item--active');
                }

                if (index === 0) {
                    allSlides.eq(allSlides.length - 1 - _.options.slidesToShow).addClass('slider__item--center');
                } else if (index === _.slideCount - 1) {
                    allSlides.eq(_.options.slidesToShow).addClass('slider__item--center');
                }

                _.$slides.eq(index).addClass('slider__item--center');
            }

        } else {

            if (index > 0 && index < (_.slideCount - _.options.slidesToShow)) {
                _.$slides.slice(index, index + _.options.slidesToShow).addClass('slider__item--active');
            } else if (allSlides.length <= _.options.slidesToShow) {
                allSlides.addClass('slider__item--active');
            } else {
                indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;
                allSlides.slice(indexOffset, indexOffset + _.options.slidesToShow).addClass('slider__item--active');
            }

        }

        if (_.options.lazyLoad === 'ondemand') {
            _.lazyLoad();
        }

    };

    Slick.prototype.setupInfinite = function () {

        var _ = this,
            i, slideIndex, infiniteCount;

        if (_.options.fade === true || _.options.vertical === true) {
            _.options.centerMode = false;
        }

        if (_.options.infinite === true && _.options.fade === false) {

            slideIndex = null;

            // if (_.slideCount > _.options.slidesToShow) {
            if (_.options.centerMode === true) {
                infiniteCount = _.options.slidesToShow + 1;
            } else {
                infiniteCount = _.options.slidesToShow;
            }
            if (_.slideCount < _.options.slidesToShow) {
                infiniteCount = _.slideCount;
            }

            for (i = _.slideCount; i > (_.slideCount - infiniteCount); i -= 1) {
                slideIndex = i - 1;
                $(_.$slides[slideIndex]).clone().attr('id', '').prependTo(
                _.$slideTrack).addClass('slider--cloned');
            }
            for (i = 0; i < infiniteCount; i += 1) {
                slideIndex = i;
                $(_.$slides[slideIndex]).clone().attr('id', '').appendTo(
                _.$slideTrack).addClass('slider--cloned');
            }
            _.$slideTrack.find('.slider--cloned').find('[id]').each(function () {
                $(this).attr('id', '');
            });

            // }
        }

    };

    Slick.prototype.slideHandler = function (index) {

        var targetSlide, animSlide, slideLeft, unevenOffset, targetLeft = null,
            _ = this;

        if (_.animating === true) {
            return false;
        }

        targetSlide = index;
        targetLeft = _.getLeft(targetSlide);
        slideLeft = _.getLeft(_.currentSlide);

        unevenOffset = _.slideCount % _.options.slidesToScroll !== 0 ? _.options.slidesToScroll : 0;

        _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

        if (_.options.infinite === false && (index < 0 || index > (_.slideCount - _.options.slidesToShow + unevenOffset))) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                _.animateSlide(slideLeft, function () {
                    _.postSlide(targetSlide);
                });
            }
            return false;
        }

        if (_.options.autoplay === true) {
            clearInterval(_.autoPlayTimer);
        }

        if (targetSlide < 0) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = _.slideCount - (_.slideCount % _.options.slidesToScroll);
            } else {
                animSlide = _.slideCount - _.options.slidesToScroll;
            }
        } else if (targetSlide > (_.slideCount - 1)) {
            animSlide = 0;
        } else {
            animSlide = targetSlide;
        }

        _.animating = true;

        if (_.options.onBeforeChange !== null && index !== _.currentSlide) {
            _.options.onBeforeChange.call(this, _, _.currentSlide, animSlide);
        }

        _.currentSlide = animSlide;

        _.setSlideClasses(_.currentSlide);

        _.updateDots();
        _.updateArrows();

        if (_.options.fade === true) {
            _.fadeSlide(animSlide, function () {
                _.postSlide(animSlide);
            });
            return false;
        }

        _.animateSlide(targetLeft, function () {
            _.postSlide(animSlide);
        });

    };

    Slick.prototype.startLoad = function () {

        var _ = this;

        // if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
        if (_.options.arrows === true) {

            _.$prevArrow.hide();
            _.$nextArrow.hide();

        }

        // if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
        if (_.options.dots === true) {

            _.$dots.hide();

        }

        _.$slider.addClass('slider--loading');

    };

    Slick.prototype.swipeDirection = function () {

        var xDist, yDist, r, swipeAngle, _ = this;

        xDist = _.touchObject.startX - _.touchObject.curX;
        yDist = _.touchObject.startY - _.touchObject.curY;
        r = Math.atan2(yDist, xDist);

        swipeAngle = Math.round(r * 180 / Math.PI);
        if (swipeAngle < 0) {
            swipeAngle = 360 - Math.abs(swipeAngle);
        }

        if ((swipeAngle <= 45) && (swipeAngle >= 0)) {
            return 'left';
        }
        if ((swipeAngle <= 360) && (swipeAngle >= 315)) {
            return 'left';
        }
        if ((swipeAngle >= 135) && (swipeAngle <= 225)) {
            return 'right';
        }

        return 'vertical';

    };

    Slick.prototype.swipeEnd = function (event) {

        var _ = this;

        _.$list.removeClass('dragging');

        if (_.touchObject.curX === undefined) {
            return false;
        }

        if (_.touchObject.swipeLength >= _.touchObject.minSwipe) {
            $(event.target).on('click.slick', function (event) {
                event.stopImmediatePropagation();
                event.stopPropagation();
                event.preventDefault();
                $(event.target).off('click.slick');
            });

            switch (_.swipeDirection()) {
            case 'left':
                _.slideHandler(_.currentSlide + _.options.slidesToScroll);
                _.touchObject = {};
                break;

            case 'right':
                _.slideHandler(_.currentSlide - _.options.slidesToScroll);
                _.touchObject = {};
                break;
            }
        } else {
            if (_.touchObject.startX !== _.touchObject.curX) {
                _.slideHandler(_.currentSlide);
                _.touchObject = {};
            }
        }

    };

    Slick.prototype.swipeHandler = function (event) {

        var _ = this;

        if ((_.options.swipe === false) || ('ontouchend' in document && _.options.swipe === false)) {
            return undefined;
        } else if ((_.options.draggable === false) || (_.options.draggable === false && !event.originalEvent.touches)) {
            return undefined;
        }

        _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ? event.originalEvent.touches.length : 1;

        _.touchObject.minSwipe = _.listWidth / _.options.touchThreshold;

        switch (event.data.action) {

        case 'start':
            _.swipeStart(event);
            break;

        case 'move':
            _.swipeMove(event);
            break;

        case 'end':
            _.swipeEnd(event);
            break;

        }

    };

    Slick.prototype.swipeMove = function (event) {

        var _ = this,
            curLeft, swipeDirection, positionOffset, touches;

        touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;

        curLeft = _.getLeft(_.currentSlide);

        if (!_.$list.hasClass('dragging') || touches && touches.length !== 1) {
            return false;
        }

        _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;
        _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;

        _.touchObject.swipeLength = Math.round(Math.sqrt(
        Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));

        swipeDirection = _.swipeDirection();

        if (swipeDirection === 'vertical') {
            return;
        }

        if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
            event.preventDefault();
        }

        positionOffset = _.touchObject.curX > _.touchObject.startX ? 1 : -1;

        if (_.options.vertical === false) {
            _.swipeLeft = curLeft + _.touchObject.swipeLength * positionOffset;
        } else {
            _.swipeLeft = curLeft + (_.touchObject.swipeLength * (_.$list.height() / _.listWidth)) * positionOffset;
        }

        if (_.options.fade === true || _.options.touchMove === false) {
            return false;
        }

        if (_.animating === true) {
            _.swipeLeft = null;
            return false;
        }

        _.setCSS(_.swipeLeft);

    };

    Slick.prototype.swipeStart = function (event) {

        var _ = this,
            touches;

        if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {
            _.touchObject = {};
            return false;
        }

        if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {
            touches = event.originalEvent.touches[0];
        }

        _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;
        _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;

        _.$list.addClass('dragging');

    };

    Slick.prototype.unfilterSlides = function () {

        var _ = this;

        if (_.$slidesCache !== null) {

            _.unload();

            _.$slideTrack.children(this.options.slide).remove();

            _.$slidesCache.appendTo(_.$slideTrack);

            _.reinit();

        }

    };

    Slick.prototype.unload = function () {

        var _ = this;

        $('.slider--cloned', _.$slider).remove();
        if (_.$dots) {
            _.$dots.remove();
        }
        if (_.$prevArrow) {
            _.$prevArrow.remove();
            _.$nextArrow.remove();
        }
        _.$slides.removeClass('slider__item slider__item--active slider__item--visible').removeAttr('style');

    };

    Slick.prototype.updateArrows = function () {

        var _ = this;

        // if (_.options.arrows === true && _.options.infinite !==
        //     true && _.slideCount > _.options.slidesToShow) {
        if (_.options.arrows === true && _.options.infinite !== true) {
            _.$prevArrow.removeClass('slick-disabled');
            _.$nextArrow.removeClass('slick-disabled');
            if (_.currentSlide === 0) {
                _.$prevArrow.addClass('slick-disabled');
                _.$nextArrow.removeClass('slick-disabled');
            } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
                _.$nextArrow.addClass('slick-disabled');
                _.$prevArrow.removeClass('slick-disabled');
            }
        }

    };

    Slick.prototype.updateDots = function () {

        var _ = this;

        if (_.$dots !== null) {

            _.$dots.find('li').removeClass('slider__item--active');
            _.$dots.find('li').eq(_.currentSlide / _.options.slidesToScroll).addClass('slider__item--active');

        }

    };

    $.fn.slick = function (options) {
        var _ = this;
        return _.each(function (index, element) {

            element.slick = new Slick(element, options);

        });
    };

    $.fn.slickAdd = function (slide, slideIndex, addBefore) {
        var _ = this;
        return _.each(function (index, element) {

            element.slick.addSlide(slide, slideIndex, addBefore);

        });
    };

    $.fn.slickCurrentSlide = function () {
        var _ = this;
        return _.get(0).slick.getCurrent();
    };

    $.fn.slickFilter = function (filter) {
        var _ = this;
        return _.each(function (index, element) {

            element.slick.filterSlides(filter);

        });
    };

    $.fn.slickGoTo = function (slide) {
        var _ = this;
        return _.each(function (index, element) {

            element.slick.slideHandler(slide);

        });
    };

    $.fn.slickNext = function () {
        var _ = this;
        return _.each(function (index, element) {

            element.slick.changeSlide({
                data: {
                    message: 'next'
                }
            });

        });
    };

    $.fn.slickPause = function () {
        var _ = this;
        return _.each(function (index, element) {

            element.slick.autoPlayClear();
            element.slick.paused = true;

        });
    };

    $.fn.slickPlay = function () {
        var _ = this;
        return _.each(function (index, element) {

            element.slick.paused = false;
            element.slick.autoPlay();

        });
    };

    $.fn.slickPrev = function () {
        var _ = this;
        return _.each(function (index, element) {

            element.slick.changeSlide({
                data: {
                    message: 'previous'
                }
            });

        });
    };

    $.fn.slickRemove = function (slideIndex, removeBefore) {
        var _ = this;
        return _.each(function (index, element) {

            element.slick.removeSlide(slideIndex, removeBefore);

        });
    };

    $.fn.slickSetOption = function (option, value, refresh) {
        var _ = this;
        return _.each(function (index, element) {

            element.slick.options[option] = value;

            if (refresh === true) {
                element.slick.unload();
                element.slick.reinit();
            }

        });
    };

    $.fn.slickUnfilter = function () {
        var _ = this;
        return _.each(function (index, element) {

            element.slick.unfilterSlides();

        });
    };

    $.fn.unslick = function () {
        var _ = this;
        return _.each(function (index, element) {

            element.slick.destroy();

        });
    };

}));

/*



  @class Debouncer



  @author

    James E Baxley III

    NewSpring Church



  @version 0.3



  @note

    Handles debouncing of events via requestAnimationFrame

    @see http://www.html5rocks.com/en/tutorials/speed/animations/
 */
var Accordion, AjaxForm, AjaxSearch, Audio, BackgroundPlayer, Checkout, Debouncer, FullScreen, Geolocation, GoogleSearch, Googleapis, Modal, NewSpringUtil, Panel, Player, Share, Slider, callback, onloadModal, onloadModalUrl, bind = function (fn, me) {
    return function () {
        return fn.apply(me, arguments);
    };
},
    extend = function (child, parent) {
        for (var key in parent) {
            if (hasProp.call(parent, key)) child[key] = parent[key];
        }

        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    },
    hasProp = {}.hasOwnProperty;

Debouncer = (function () {
    function Debouncer(data1) {
        this.data = data1;
        this.handleEvent = bind(this.handleEvent, this);
        this.requestTick = bind(this.requestTick, this);
        this.update = bind(this.update, this);
        window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
        this.callback = this.data;
        this.ticking = false;
    }

    Debouncer.prototype.update = function () {
        this.callback && this.callback();
        return this.ticking = false;
    };

    Debouncer.prototype.requestTick = function () {
        if (!this.ticking) {
            requestAnimationFrame(this.rafCallback || (this.rafCallback = this.update.bind(this)));
            return this.ticking = true;
        }
    };

    Debouncer.prototype.handleEvent = function () {
        return this.requestTick();
    };

    return Debouncer;

})();

window.Debouncer = Debouncer;


/*

@class NewSpringUtil

@author
  James E Baxley III
  NewSpring Church

@version 0.4
 */

NewSpringUtil = (function () {

/*
  
  	  Constructor function runs when object gets initialized
  
  	  @param {Ojbect} options for setting up the class
   */

    function NewSpringUtil(data1) {
        this.data = data1;
        this.flattenObject = bind(this.flattenObject, this);
        this.findAttr = bind(this.findAttr, this);
        this.removeClass = bind(this.removeClass, this);
        this.addClass = bind(this.addClass, this);
        this.toggleClass = bind(this.toggleClass, this);
        this.preCacheVideos = bind(this.preCacheVideos, this);
        this.preCacheImgs = bind(this.preCacheImgs, this);
        this.isMobile = bind(this.isMobile, this);
        this.debounce = bind(this.debounce, this);
        this.addModel = bind(this.addModel, this);
        this.updateModels = bind(this.updateModels, this);
        this.nameSpace = bind(this.nameSpace, this);
        this.addPlugin = bind(this.addPlugin, this);
        this.mapEvents = bind(this.mapEvents, this);
        this._properties = {
            data: data
        };
        this['plugins'] = {};
        if (typeof EventEmitter !== "undefined" && EventEmitter !== null) {
            this.events = new EventEmitter();
        }
        this.mapEvents().bindSmoothScroll();
    }


/*
  
  @FUNCTIONS
   */

    NewSpringUtil.prototype.mapEvents = function () {
        return this;
    };


/*
  
    @important
  
    Plugin framework defined below
   */

    NewSpringUtil.prototype.addPlugin = function (name, obj, attr, cb) {
        var j, len, plugin, ref, savePlugin;
        savePlugin = (function (_this) {
            return function (name, obj, attr, cb) {
                return _this['plugins'][name] = {
                    _id: name,
                    model: obj,
                    attr: attr,
                    callback: cb
                };
            };
        })(this);
        if (this.plugins.length) {
            ref = this.plugins;
            for (j = 0, len = ref.length; j < len; j++) {
                plugin = ref[j];
                if (plugin._id !== obj.name) {
                    savePlugin(name, obj, attr, cb);
                }
                this.addModel(document, obj, attr, cb);
                return;
            }
        } else {
            savePlugin(name, obj, attr, cb);
        }
        return this.addModel(document, obj, attr, cb);
    };

    NewSpringUtil.prototype.nameSpace = function (target, attribute, obj, force) {
        var originalAttr, params;
        originalAttr = attribute.replace(/[\[\]']+/g, '');
        params = target.attributes[originalAttr].value.split(',');
        params = params.map(function (param) {
            return param.trim();
        });
        attribute = originalAttr.split('-');
        if (!this[attribute[1]]) {
            this[attribute[1]] = {};
        }
        if (!this[attribute[1]][params[0]]) {
            this[attribute[1]][params[0]] = new obj(target, originalAttr);
        }
        if (force) {
            this[attribute[1]][params[0]] = null;
            return this[attribute[1]][params[0]] = new obj(target, originalAttr);
        }
    };

    NewSpringUtil.prototype.updateModels = function (scope, force) {
        var j, len, plugin, ref, results1;
        ref = core.flattenObject(this['plugins']);
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
            plugin = ref[j];
            results1.push(this.addModel(scope, plugin.model, plugin.attr, false, force));
        }
        return results1;
    };

    NewSpringUtil.prototype.addModel = function (scope, model, attr, cb, force) {
        var j, len, ref, target;
        ref = scope.querySelectorAll(attr);
        for (j = 0, len = ref.length; j < len; j++) {
            target = ref[j];
            this.nameSpace(target, attr, model, force);
        }
        if (scope.querySelectorAll(attr).length) {
            if (cb) {
                return cb();
            }
        }
    };


/*
  
    @important
  
    End plugin framework
   */

    NewSpringUtil.prototype.bindLazyLoad = function () {
        if (typeof echo !== "undefined" && echo !== null) {
            echo.init({
                offset: 100,
                throttle: 250,
                unload: false
            });
            return this;
        }
    };

    NewSpringUtil.prototype.bindSmoothScroll = function () {
        if (typeof smoothScroll !== "undefined" && smoothScroll !== null) {
            return smoothScroll.init({
                "offset": 0,
                "updateURL": false
            });
        }
    };


/*
  
  @function debounce()
  
  @param {Function} call back to be debounced on multifire resize
  
  @return new Debonce object
   */

    NewSpringUtil.prototype.debounce = function (callback) {
        var debouncing;
        debouncing = null;
        return debouncing != null ? debouncing : debouncing = new Debouncer(callback);
    };


/*
  
  @function doesVariableExist()
  
  @param {Val} for query variable
  
  @return {Boolean} if query varible exists
   */

    NewSpringUtil.prototype.doesVariableExist = function (val) {
        var element, pair, query, vars;
        query = window.location.search.substring(1);
        vars = query.split("&");
        for (element in vars) {
            pair = vars[element].split("=");
            if (decodeURIComponent(pair[1]) === val) {
                return true;
            }
        }
        return false;
    };


/*
  
  @function doesQueryVariableExist()
  
  @param {Val} for query variable
  
  @return {Boolean} if query varible exists
   */

    NewSpringUtil.prototype.doesQueryVariableExist = function (val) {
        var element, pair, query, vars;
        query = window.location.search.substring(1);
        vars = query.split("&");
        for (element in vars) {
            pair = vars[element].split("=");
            if (decodeURIComponent(pair[0]) === val) {
                return true;
            }
        }
        return false;
    };


/*
  
  @function flatten()
  
  @param {Array} single or multilevel array
  
  @return {Array} a flattened version of an array.
  
  @note
    Handy for getting a list of children from the nodes.
   */

    NewSpringUtil.prototype.flatten = function (array) {
        var element, flattened, j, len;
        flattened = [];
        for (j = 0, len = array.length; j < len; j++) {
            element = array[j];
            if (element instanceof Array) {
                flattened = flattened.concat(this.flatten(element));
            } else {
                flattened.push(element);
            }
        }
        return flattened;
    };


/*
  
  @function getKeys()
  
  @param {Object}
  @param {value}
  
  @return {Array} array of keys that match on a certain value
  
  @note
    helpful for searching objects
  
  
  @todo add ability to search string and multi level
   */

    NewSpringUtil.prototype.getKeys = function (obj, val) {
        var element, objects;
        objects = [];
        for (element in obj) {
            if (!obj.hasOwnProperty(element)) {
                continue;
            }
            if (obj[element] === "object") {
                objects = objects.concat(this.getKeys(obj[element], val));
            } else {
                if (obj[element] === val) {
                    objects.push(element);
                }
            }
        }
        return objects;
    };


/*
  
  @function getQueryVariable()
  
  @param {Val}
  
  @return {Array} array of query values in url string matching the value
   */

    NewSpringUtil.prototype.getQueryVariable = function (val) {
        var query, results, vars;
        query = window.location.search.substring(1);
        vars = query.split("&");
        results = vars.filter(function (element) {
            var pair;
            pair = element.split("=");
            if (decodeURIComponent(pair[0]) === val) {
                return decodeURIComponent(pair[1]);
            }
        });
        return results;
    };


/*
  
  @function isElementInView()
  
  @param {Element} element to check against
  
  @return {Boolean} if element is in view
   */

    NewSpringUtil.prototype.isElementInView = function (element) {
        var coords;
        if (element instanceof jQuery) {
            element = element.get(0);
        }
        coords = element.getBoundingClientRect();
        return (Math.abs(coords.left) >= 0 && Math.abs(coords.top)) <= (window.innerHeight || document.documentElement.clientHeight);
    };


/*
  
  @function isMobile()
  
  @return {Boolean} true if Mobile
   */

    NewSpringUtil.prototype.isMobile = function () {
        var mobile;
        return mobile = /(Android|iPhone|iPad|iPod|IEMobile)/g.test(navigator.userAgent);
    };


/*
  
  @function last()
  
  @param {Array}
  @param {Val} ** optional
  
  @return {Val} last value of array or value certain length from end
   */

    NewSpringUtil.prototype.last = function (array, back) {
        return array[array.length - (back || 0) - 1];
    };


/*
  
  @function preCacheImgs()
  
  @param {Array} array of img src
  
  @chainable
   */

    NewSpringUtil.prototype.preCacheImgs = function (array) {
        var cache;
        cache = function (array) {
            var i, img, results1, url;
            i = 0;
            results1 = [];
            while (i < array.length) {
                url = array[i];
                img = new Image();
                img.src = url;
                results1.push(i++);
            }
            return results1;
        };
        cache(array);
        return this;
    };


/*
  
  @function preCacheVideos()
  
  @param {Array} array of video src
  
  @chainable
   */

    NewSpringUtil.prototype.preCacheVideos = function (array) {
        var cache;
        cache = function (array) {
            var i, results1, url, video;
            i = 0;
            results1 = [];
            while (i < array.length) {
                url = array[i];
                video = document.createElement('video');
                video.src = url;
                results1.push(i++);
            }
            return results1;
        };
        cache(array);
        return this;
    };


/*
  
  @function toggleClass()
  
  @param {Element} element to be toggled
  
  @param {String} classname to be toggled
  
  @chainable
   */

    NewSpringUtil.prototype.toggleClass = function (element, klassName) {
        var klassString, nameIndex;
        if (!element || !klassName) {
            return this;
        }
        if (element instanceof jQuery) {
            element = element.get(0);
        }
        klassString = element.className;
        nameIndex = klassString.indexOf(klassName);
        if (nameIndex === -1) {
            klassString += " " + klassName;
        } else {
            klassString = klassString.substr(0, nameIndex) + klassString.substr(nameIndex + klassName.length);
        }
        element.className = klassString.trim();
        return this;
    };

    NewSpringUtil.prototype.hasClass = function (elem, className) {
        return new RegExp(" " + className + " ").test(" " + elem.className + " ");
    };

    NewSpringUtil.prototype.addClass = function (elem, className) {
        if (!this.hasClass(elem, className)) {
            elem.className += " " + className;
        }
        return this;
    };

    NewSpringUtil.prototype.removeClass = function (elem, className) {
        var newClass;
        newClass = " " + elem.className.replace(/[\t\r\n]/g, " ") + " ";
        if (this.hasClass(elem, className)) {
            while (newClass.indexOf(" " + className + " ") >= 0) {
                newClass = newClass.replace(" " + className + " ", " ");
            }
            elem.className = newClass.replace(/^\s+|\s+$/g, "");
        }
        return this;
    };

    NewSpringUtil.prototype.findAttr = function (element, searchTerm) {
        var attr, attributes, j, len;
        if (element != null) {
            attributes = this.flatten(element.attributes);
            for (j = 0, len = attributes.length; j < len; j++) {
                attr = attributes[j];
                if (!attr.name.indexOf(searchTerm)) {
                    return {
                        'ele': element,
                        'attrName': attr.name,
                        'attrVal': attr.value
                    };
                }
            }
            return this.findAttr(element.parentElement, searchTerm);
        }
    };


/*
  
  @function truthful()
  
  @param {Array} any array to be tested for true values
  
  @return {Array} array without false values
  
  @note
    Handy for triming out all falsy values from an array.
   */

    NewSpringUtil.prototype.truthful = function (array) {
        var item, j, len, results1;
        results1 = [];
        for (j = 0, len = array.length; j < len; j++) {
            item = array[j];
            if (item) {
                results1.push(item);
            }
        }
        return results1;
    };

    NewSpringUtil.prototype.flattenObject = function (object) {
        var array, value;
        array = [];
        for (value in object) {
            if (object.hasOwnProperty(value)) {
                array.push(object[value]);
            }
        }
        return array;
    };

    NewSpringUtil.prototype.isElement = function (o) {
        if (typeof HTMLElement === "object") {
            return o instanceof HTMLElement;
        } else {
            return o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
        }
    };

    return NewSpringUtil;

})();

window.core = new NewSpringUtil;


/*
@class Accordion

@author
  James E Baxley III
  NewSpring Church

@version 0.1

@note
  Handles interactions of accordions based on data- parameters
 */

Accordion = (function () {
    function Accordion(data1, attr) {
        var json, meta, params;
        this.data = data1;
        this.expandBellow = bind(this.expandBellow, this);
        this.bindClicks = bind(this.bindClicks, this);
        params = this.data.attributes[attr].value.split(',');
        params = params.map(function (param) {
            return param.trim();
        });
        if (params.length > 3) {
            meta = params.splice(0, 2);
            json = params.join(',');
            params = meta.concat(json);
        }
        this._properties = {
            _id: params[0],
            target: this.data,
            type: params[1]
        };
        if (typeof EventEmitter !== "undefined" && EventEmitter !== null) {
            this.events = new EventEmitter();
        }
        this.bindClicks();
    }

    Accordion.prototype.bindClicks = function () {
        var j, len, results1, trigger, triggers;
        triggers = this._properties.target.querySelectorAll('[data-accordion-trigger]');
        this._properties.triggers = triggers;
        results1 = [];
        for (j = 0, len = triggers.length; j < len; j++) {
            trigger = triggers[j];
            results1.push(trigger.addEventListener('click', this.expandBellow, false));
        }
        return results1;
    };

    Accordion.prototype.expandBellow = function (event) {
        var bellow, j, klassName, len, otherBellow, ref, trigger;
        event.preventDefault();
        klassName = 'expanded';
        bellow = this.findClosestBellow(event.target);
        core.toggleClass(bellow, klassName);
        if (this._properties.type !== 'multi') {
            ref = this._properties.triggers;
            for (j = 0, len = ref.length; j < len; j++) {
                trigger = ref[j];
                otherBellow = this.findClosestBellow(trigger);
                if (otherBellow !== bellow) {
                    core.removeClass(otherBellow, klassName);
                }
            }
        }
        this.events.emit('toggled', event);
        return this;
    };

    Accordion.prototype.findClosestBellow = function (trigger) {
        var currentNode, klass;
        klass = 'accordion__item';
        currentNode = trigger;
        while (!core.hasClass(currentNode, klass)) {
            currentNode = currentNode.parentNode;
        }
        return currentNode;
    };

    return Accordion;

})();

if (typeof core !== "undefined" && core !== null) {
    core.addPlugin('Accordion', Accordion, '[data-accordion]');
}


/*
@class AjaxForm

@author
  James E Baxley III
  NewSpring Church

@version 0.1

@note
  Handles interactions of forms based on data- parameters
 */

AjaxForm = (function () {
    function AjaxForm(data1, attr) {
        var e, id, j, json, len, linked, meta, params, trigger, triggers;
        this.data = data1;
        this.returnErrors = bind(this.returnErrors, this);
        this.cleanErrors = bind(this.cleanErrors, this);
        this.successMessage = bind(this.successMessage, this);
        this.successRedirect = bind(this.successRedirect, this);
        this.updateCartForm = bind(this.updateCartForm, this);
        this.bindAjax = bind(this.bindAjax, this);
        this.matchFields = bind(this.matchFields, this);
        this.bindForms = bind(this.bindForms, this);
        params = this.data.attributes[attr].value.split(',');
        params = params.map(function (param) {
            return param.trim();
        });
        if (params.length > 2) {
            meta = params.splice(0, 2);
            json = params.join(',');
            params = meta.concat(json);
        }
        linked = false;
        if (this.data.attributes[attr + '-link'] !== undefined) {
            id = this.data.attributes[attr + '-link'].value;
            linked = document.querySelectorAll('[' + attr + '-link="' + id + '"]')[0];
            linked = linked.form;
        }
        this._properties = {
            attr: attr,
            _id: params[0],
            target: this.data.form,
            linked: linked,
            response: (function () {
                try {
                    return JSON.parse(params[2]);
                } catch (_error) {
                    e = _error;
                    return void 0;
                }
            })(),
            auto: (function () {
                try {
                    return JSON.parse(params[1]);
                } catch (_error) {
                    e = _error;
                    return false;
                }
            })(),
            triggers: {}
        };
        triggers = ['error'];
        for (j = 0, len = triggers.length; j < len; j++) {
            trigger = triggers[j];
            this._properties.triggers[trigger] = document.querySelectorAll('[' + attr + '-' + trigger + '*="' + params[0] + '"]');
        }
        if (typeof EventEmitter !== "undefined" && EventEmitter !== null) {
            this.events = new EventEmitter();
        }
        this.bindAjax();
        if (this._properties.linked) {
            this.bindForms();
        }
    }

    AjaxForm.prototype.bindForms = function () {
        var linked, original;
        linked = this.getFields(this._properties.linked);
        original = this.getFields(this._properties.target);
        return this._properties.linkedFields = this.filterFields(original, linked);
    };

    AjaxForm.prototype.filterFields = function (array1, array2) {
        var matching;
        matching = array1.filter(function (input) {
            var j, len, link;
            for (j = 0, len = array2.length; j < len; j++) {
                link = array2[j];
                if (link.name.indexOf(input.name) > -1 || input.name.indexOf(link.name) > -1 && input.name.length > 0 && link.name.length > 0) {
                    link.dataset.link = link.name;
                    input.dataset.link = link.name;
                    return true;
                }
            }
        });
        return matching;
    };

    AjaxForm.prototype.getFields = function (form) {
        var fields, input, inputs, j, k, len, len1, select, selects;
        inputs = form.getElementsByTagName('INPUT');
        selects = form.getElementsByTagName('SELECT');
        fields = [];
        for (j = 0, len = inputs.length; j < len; j++) {
            input = inputs[j];
            fields.push(input);
        }
        for (k = 0, len1 = selects.length; k < len1; k++) {
            select = selects[k];
            fields.push(select);
        }
        return fields;
    };

    AjaxForm.prototype.matchFields = function () {
        var input, j, len, ref, results1, sync;
        sync = function (input) {
            var linked, value;
            value = input.value;
            linked = document.querySelectorAll('[data-link="' + input.dataset.link + '"]')[0];
            if (linked.type !== 'hidden') {
                return linked.value = value;
            }
        };
        ref = this._properties.linkedFields;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
            input = ref[j];
            results1.push(sync(input));
        }
        return results1;
    };

    AjaxForm.prototype.bindAjax = function () {
        var delay, plugin, submit;
        plugin = this;
        $(this._properties.target).ajaxForm({
            dataType: "json",
            beforeSubmit: function (arr, $form, options) {
                var field, form, j, len, mapped, mappedField, submitBtn;
                if (!plugin._properties.processing) {
                    if (plugin._properties.linked) {
                        submitBtn = plugin._properties.target.querySelectorAll('[name="submit"]')[0];
                        plugin._properties.processing = true;
                        submitBtn.dataset.originalText = submitBtn.value;
                        core.addClass(submitBtn, 'btn--icon');
                        submitBtn.value = 'Purchasing...';
                        plugin.matchFields();
                        if (core.mappedFields !== undefined) {
                            form = plugin._properties.target;
                            for (field in core.mappedFields) {
                                mappedField = form.querySelectorAll('[name="' + field + '"]');
                                for (j = 0, len = mappedField.length; j < len; j++) {
                                    mapped = mappedField[j];
                                    mapped.value = core.mappedFields[field];
                                }
                            }
                        }
                        return $(plugin._properties.linked).ajaxSubmit();
                    }
                } else {
                    return false;
                }
            },
            success: function (data) {
                var submitBtn;
                submitBtn = plugin._properties.target.querySelectorAll('[name="submit"]')[0];
                if (submitBtn != null) {
                    plugin._properties.processing = false;
                    core.removeClass(submitBtn, 'btn--icon');
                    submitBtn.value = submitBtn.dataset.originalText;
                }
                if (data.success) {
                    if (document.querySelectorAll('.panel--active .form--error')) {
                        plugin.cleanErrors();
                    }
                    if (document.querySelector('.panel--active .form--success')) {
                        plugin.successMessage();
                    }
                    if (!plugin._properties.auto) {
                        if (plugin._properties.response !== undefined) {
                            core['panel'][plugin._properties.response['panel-group']].loadPanel(plugin._properties.response['panel'], true);
                        } else {
                            location.reload(false);
                        }
                    }
                    if (document.querySelectorAll('.panel--active [data-ajaxForm-success]')[0]) {
                        return plugin.successRedirect();
                    }
                } else {
                    plugin.cleanErrors();
                    if (data.XID != null) {
                        plugin.updateCartForm(data);
                    }
                    if (data.errors) {
                        plugin.returnErrors(data.errors);
                    }
                    if (data.field_errors) {
                        return plugin.returnErrors(data.field_errors);
                    }
                }
            },
            failure: function (data) {
                console.log(data, 'failure');
            }
        });
        if (this._properties.auto) {
            submit = (function (_this) {
                return function () {
                    return $(_this._properties.target).submit();
                };
            })(this);
            return delay = setTimeout(submit, 10);
        }
    };

    AjaxForm.prototype.updateCartForm = function (data) {
        return this._properties.target.querySelectorAll('input[name=XID]').value = data.XID;
    };

    AjaxForm.prototype.successRedirect = function () {
        var panelRedirect, panelRedirectURL;
        panelRedirect = document.querySelectorAll('.panel--active [data-ajaxForm-success]')[0];
        panelRedirectURL = panelRedirect.getAttribute('data-ajaxForm-success');
        return window.location.href = panelRedirectURL;
    };

    AjaxForm.prototype.successMessage = function () {
        var successSection;
        successSection = document.querySelector('.panel--active .form--success');
        return core.removeClass(successSection, 'visuallyhidden');
    };

    AjaxForm.prototype.cleanErrors = function () {
        var error, errorContainer, errorToClear, errors, j, len, ref, results1;
        ref = this._properties.triggers.error;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
            errorContainer = ref[j];
            errors = errorContainer.querySelectorAll('.form--error');
            results1.push((function () {
                var k, len1, results2;
                results2 = [];
                for (k = 0, len1 = errors.length; k < len1; k++) {
                    error = errors[k];
                    if (errorContainer.getElementsByClassName('form--label')[0]) {
                        errorToClear = errorContainer.getElementsByClassName('form--label')[0];
                        core.removeClass(errorToClear, 'visuallyhidden');
                    }
                    core.removeClass(errorContainer, 'error');
                    results2.push(error.parentNode.removeChild(error));
                }
                return results2;
            })());
        }
        return results1;
    };

    AjaxForm.prototype.returnErrors = function (error) {
        var createMessage, errorContainer, errorType, j, len, message, ref;
        createMessage = (function (_this) {
            return function (message, container) {
                var errorMessage, input, inputs, j, label, len;
                errorMessage = document.createElement('span');
                core.addClass(errorMessage, 'form--error');
                errorMessage.innerText = message;
                inputs = container.getElementsByTagName("INPUT");
                for (j = 0, len = inputs.length; j < len; j++) {
                    input = inputs[j];
                    input.addEventListener('focus', _this.cleanErrors);
                }
                container.appendChild(errorMessage);
                core.addClass(container, 'error');
                if (container.getElementsByClassName('form--label')[0]) {
                    label = container.getElementsByClassName('form--label')[0];
                    return core.addClass(label, 'visuallyhidden');
                }
            };
        })(this);
        console.log(this._properties);
        ref = this._properties.triggers.error;
        for (j = 0, len = ref.length; j < len; j++) {
            errorContainer = ref[j];
            errorType = errorContainer.attributes[this._properties.attr + '-error'].value.split(',')[1].trim();
            if (error[errorType] != null) {
                createMessage(error[errorType], errorContainer);
                return;
            } else if (errorType === 'default') {
                message = core.flattenObject(error).join(' and ');
                createMessage(message, errorContainer);
            }
        }
    };

    return AjaxForm;

})();

if (typeof core !== "undefined" && core !== null) {
    core.addPlugin('AjaxForm', AjaxForm, '[data-ajaxForm]');
}


/*
Base class for all input controlled AJAX live searches

@author
  James E Baxley III
  NewSpring Church

@version 0.1

@param {Object} options for setting up the class


@example Extending within another class
  class GoogleSearch extends AjaxSearch

@example Initiating an AJAX search
  var livesearch = new AjaxSearch sampleData
 */

AjaxSearch = (function () {

/*
  Constructor function runs when object gets initialized
  
  @param {Object} options for setting up the class
   */

    function AjaxSearch(data1, attr, config) {
        var autocompleteData, e, j, json, len, meta, params, trigger, triggers;
        this.data = data1;
        this.extend = bind(this.extend, this);
        this.showPage = bind(this.showPage, this);
        this.prepResults = bind(this.prepResults, this);
        this.validate = bind(this.validate, this);
        this.search = bind(this.search, this);
        this.updateUrl = bind(this.updateUrl, this);
        this.bindAutoComplete = bind(this.bindAutoComplete, this);
        this.bindTriggers = bind(this.bindTriggers, this);
        this.bindKeyup = bind(this.bindKeyup, this);
        this.getQueryVariable = bind(this.getQueryVariable, this);
        this.storeQueryTerm = bind(this.storeQueryTerm, this);
        this.manageClasses = bind(this.manageClasses, this);
        this.mapEvents = bind(this.mapEvents, this);
        this.bindAutofill = bind(this.bindAutofill, this);
        this.clean = bind(this.clean, this);
        if (this.data instanceof jQuery) {
            this.data = this.data.get(0);
        }
        params = this.data.attributes[attr].value.split(',');
        params = params.map(function (param) {
            return param.trim();
        });
        if (params.length > 2) {
            meta = params.splice(0, 1);
            json = params.join(',');
            params = meta.concat(json);
        }
        autocompleteData = (function () {
            try {
                return JSON.parse(this.data.attributes['data-google-search-autocomplete'].value);
            } catch (_error) {
                e = _error;
                return null;
            }
        }).call(this);
        this._properties = {
            _id: params[0],
            type: config._id,
            params: (function () {
                try {
                    return JSON.parse(params[1]);
                } catch (_error) {
                    e = _error;
                    return {};
                }
            })(),
            target: this.data,
            autocomplete: autocompleteData,
            triggers: {},
            query: {},
            config: config,
            response: {
                target: document.querySelectorAll('[' + attr + '-results="' + params[0] + '"]')[0]
            }
        };
        if (typeof EventEmitter !== "undefined" && EventEmitter !== null) {
            this.events = new EventEmitter();
        }
        triggers = ['open', 'close', 'trigger'];
        for (j = 0, len = triggers.length; j < len; j++) {
            trigger = triggers[j];
            this._properties.triggers[trigger] = document.querySelectorAll('[' + attr + '-' + trigger + '="' + params[0] + '"]')[0];
        }
        this.mapEvents().bindKeyup().bindAutoComplete().extend();
        if ((this._properties.triggers.open != null) || (this._properties.triggers.close != null) || (this._properties.triggers.trigger != null)) {
            this.bindTriggers();
        }
        this._properties.triggers['link'] = document.querySelectorAll('[' + attr + '-link="' + params[0] + '"]');
        if (this._properties.triggers.link != null) {
            this.bindAutofill();
        }
        this.events.emit('search-ready');
    }


/*
  
    @.clean()
  
    @note
      Resets all search params and states
   */

    AjaxSearch.prototype.clean = function () {
        var response, results1;
        this._properties.target.value = '';
        this._properties.query = {};
        history.pushState('', '', window.location.origin + (window.location.pathname || ''));
        core.removeClass(this._properties.target, 'searching');
        core.addClass(this._properties.target, 'search');
        core.addClass(this._properties.response.target, 'searching');
        core.removeClass(this._properties.response.target, 'results--returned');
        response = this._properties.response.target;
        results1 = [];
        while (response.firstChild) {
            results1.push(response.removeChild(response.firstChild));
        }
        return results1;
    };

    AjaxSearch.prototype.bindAutofill = function () {
        var j, len, link, ref, search;
        ref = this._properties.triggers.link;
        for (j = 0, len = ref.length; j < len; j++) {
            link = ref[j];
            search = (function (_this) {
                return function () {
                    var linkText;
                    linkText = event.target.innerHTML.replace(/[\.,-\/#!$%\^&\*;:{}=\-_`~()]/g, "").trim();
                    return _this.events.emit('search', linkText);
                };
            })(this);
            link.addEventListener('click', search, false);
        }
        return this;
    };

    AjaxSearch.prototype.mapEvents = function () {
        this.events.on('clean', this.clean);
        this.events.on('search-ready', (function (_this) {
            return function () {
                _this._properties.target.value = _this.getQueryVariable();
                _this.manageClasses('search-ready');
                if (_this._properties.target.value.length > 3) {
                    return _this.events.emit('search', _this._properties.target.value);
                }
            };
        })(this));
        $(this._properties.target).bind('typeahead:selected', (function (_this) {
            return function (event) {
                _this._properties.target.blur();
                return _this.events.emit('search', event.target.value);
            };
        })(this));
        this.events.on('search', (function (_this) {
            return function (query) {
                var body;
                if (query !== _this._properties.query._search) {
                    _this._properties.query = {};
                }
                _this.storeQueryTerm(query);
                _this._properties.target.blur();
                _this._properties.target.value = query;
                body = document.getElementsByTagName('BODY')[0];
                if (query === 'do a barrel roll') {
                    core.addClass(body, 'roll');
                } else {
                    core.removeClass(body, 'roll');
                }
                _this.events.emit('query-changed');
                return _this.search();
            };
        })(this));
        this.events.on('query-changed', this.updateUrl);
        this.events.on('searching', (function (_this) {
            return function () {
                return _this.manageClasses('searching');
            };
        })(this));
        this.events.on('result', (function (_this) {
            return function (result) {
                return _this.validate(result);
            };
        })(this));
        this.events.on('results-prep', (function (_this) {
            return function (result) {
                return _this.prepResults(result);
            };
        })(this));
        this.events.on('results-ready', (function (_this) {
            return function (result) {
                return _this.showPage(result);
            };
        })(this));
        this.events.on('results-rendered', (function (_this) {
            return function (result) {
                return _this.manageClasses('results--returned');
            };
        })(this));
        return this;
    };

    AjaxSearch.prototype.manageClasses = function (action) {
        var containers, element, j, k, l, len, len1, len2, len3, len4, len5, m, n, p, results1, results2, results3;
        containers = [this._properties.target, this._properties.triggers.open, this._properties.triggers.close, this._properties.response.target];
        containers = containers.filter(core.isElement);
        switch (action) {
        case 'search-ready':
            results1 = [];
            for (j = 0, len = containers.length; j < len; j++) {
                element = containers[j];
                results1.push(core.addClass(element, action));
            }
            return results1;
            break;
        case 'searching':
            for (k = 0, len1 = containers.length; k < len1; k++) {
                element = containers[k];
                core.removeClass(element, 'search-ready');
            }
            results2 = [];
            for (l = 0, len2 = containers.length; l < len2; l++) {
                element = containers[l];
                results2.push(core.addClass(element, action));
            }
            return results2;
            break;
        case 'results--returned':
            for (m = 0, len3 = containers.length; m < len3; m++) {
                element = containers[m];
                core.addClass(element, 'search-ready');
            }
            for (n = 0, len4 = containers.length; n < len4; n++) {
                element = containers[n];
                core.removeClass(element, 'searching');
            }
            results3 = [];
            for (p = 0, len5 = containers.length; p < len5; p++) {
                element = containers[p];
                results3.push(core.addClass(element, action));
            }
            return results3;
        }
    };

    AjaxSearch;

    AjaxSearch.prototype.storeQueryTerm = function (query) {
        this._properties.query._search = query;
        return this;
    };

    AjaxSearch.prototype.getQueryVariable = function () {
        var j, key, len, query, queryTerm, term, vars;
        query = window.location.search.substring(1);
        vars = query.split("?")[0].split("&");
        if (window.location.hash.split('#')[1] === this._properties._id) {
            for (j = 0, len = vars.length; j < len; j++) {
                term = vars[j];
                key = term.split("=")[0];
                if (key === "search") {
                    queryTerm = decodeURIComponent(term.split("=")[1]);
                    this.storeQueryTerm(queryTerm);
                } else {
                    if (key && term) {
                        this._properties.query[key] = term;
                    }
                }
            }
            this.events.emit('open');
        }
        if (queryTerm == null) {
            queryTerm = '';
        }
        return queryTerm;
    };

    AjaxSearch.prototype.bindKeyup = function () {
        this._properties.target.addEventListener('keyup', (function (_this) {
            return function (event) {
                var input;
                input = _this._properties.target;
                if (input.value.length === 0) {
                    _this.events.emit('clean');
                }
                if (event.keyCode === 13) {
                    return _this.events.emit('search', input.value);
                }
            };
        })(this), false);
        return this;
    };

    AjaxSearch.prototype.bindTriggers = function () {
        var close, open, search;
        this.events.on('open', (function (_this) {
            return function () {
                if (!core.hasClass(_this._properties.target, 'active')) {
                    _this._properties.target.focus();
                }
                core.toggleClass(_this._properties.target, 'active');
                return setTimeout(function () {
                    return _this.events.emit('extend-open');
                }, 0);
            };
        })(this));
        this.events.on('close', (function (_this) {
            return function () {
                core.toggleClass(_this._properties.target, 'active');
                setTimeout(function () {
                    return _this.events.emit('extend-close');
                }, 0);
                return _this.events.emit('clean');
            };
        })(this));
        if ((this._properties.triggers.open != null) && core.isElement(this._properties.triggers.open)) {
            open = (function (_this) {
                return function () {
                    return _this.events.emit('open');
                };
            })(this);
            this._properties.triggers.open.addEventListener('click', open, false);
        }
        if ((this._properties.triggers.close != null) && core.isElement(this._properties.triggers.close)) {
            close = (function (_this) {
                return function () {
                    return _this.events.emit('close');
                };
            })(this);
            this._properties.triggers.close.addEventListener('click', close, false);
        }
        if ((this._properties.triggers.trigger != null) && core.isElement(this._properties.triggers.trigger)) {
            search = (function (_this) {
                return function (e) {
                    return _this.events.emit('search', _this._properties.target.value);
                };
            })(this);
            return this._properties.triggers.trigger.addEventListener('click', search, false);
        }
    };

    AjaxSearch.prototype.bindAutoComplete = function () {
        var autocomplete, bloodhoundObj, dataSets, element, j, key, len, name, nameSpace, ref, setUpBloodhound, template, templateName, value;
        if (this._properties.autocomplete != null) {
            if (typeof Bloodhound !== "undefined" && Bloodhound !== null) {
                setUpBloodhound = (function (_this) {
                    return function (nameSpace) {
                        var bloodhoundObj;
                        bloodhoundObj = nameSpace[0];
                        return bloodhoundObj = new Bloodhound({
                            datumTokenizer: function (d) {
                                return Bloodhound.tokenizers.whitespace(d[nameSpace[1]]);
                            },
                            queryTokenizer: Bloodhound.tokenizers.whitespace,
                            prefetch: nameSpace[3]
                        });
                    };
                })(this);
                dataSets = [];
                ref = this._properties.autocomplete;
                for (j = 0, len = ref.length; j < len; j++) {
                    element = ref[j];
                    nameSpace = [];
                    for (key in element) {
                        name = key;
                        value = element[key];
                        nameSpace.push(name, value);
                    }
                    bloodhoundObj = setUpBloodhound(nameSpace);
                    bloodhoundObj.initialize();
                    templateName = nameSpace[0];
                    template = Handlebars.getTemplate('search_' + templateName, true);
                    autocomplete = {
                        name: nameSpace[0],
                        displayKey: nameSpace[1],
                        source: bloodhoundObj.ttAdapter(),
                        templates: {
                            suggestion: template
                        }
                    };
                    dataSets.push(autocomplete);
                }
                $(this._properties.target).typeahead({
                    highlight: true,
                    hint: false
                }, dataSets);
            }
        }
        return this;
    };

    AjaxSearch.prototype.updateUrl = function () {
        var queries, urlString;
        queries = core.flattenObject(this._properties.query);
        if (queries.length > 1) {
            urlString = '?search=' + queries.join('&') + '#' + this._properties._id;
        } else {
            urlString = '?search=' + queries[0] + '#' + this._properties._id;
        }
        if (window.history != null) {
            return history.pushState('', '', urlString);
        }
    };

    AjaxSearch.prototype.search = function () {
        var ajax, arr, encodedQueries, j, len, queries, query, url;
        url = core.flattenObject(this._properties.config[this._properties.type]);
        queries = core.flattenObject(this._properties.query);
        if (queries.length > 1) {
            encodedQueries = [];
            for (j = 0, len = queries.length; j < len; j++) {
                query = queries[j];
                if (query.indexOf('=') > 0) {
                    arr = query.split('=');
                    query = arr[0] + "=" + encodeURIComponent(arr[1]);
                } else {
                    query = encodeURIComponent(query);
                }
                encodedQueries.push(query);
            }
            queries = encodedQueries.join('&');
        } else {
            queries = encodeURIComponent(queries[0]);
        }
        url = url.join('&') + '&q=' + queries;
        ajax = new XMLHttpRequest();
        ajax.onreadystatechange = (function (_this) {
            return function () {
                if (ajax.readyState !== 4 || ajax.status !== 200) {
                    return;
                }
                return _this.events.emit('result', JSON.parse(ajax.response));
            };
        })(this);
        ajax.open("GET", url, true);
        ajax.send();
        return this.events.emit('searching');
    };

    AjaxSearch.prototype.validate = function (result) {
        if (JSON.stringify(result) !== JSON.stringify(this._properties.response.data)) {
            result = result;
        }
        this._properties.response.data = result;
        return this.events.emit('results-prep', result);
    };

    AjaxSearch.prototype.prepResults = function (results) {
        return this.events.emit('results-ready', results);
    };

    AjaxSearch.prototype.showPage = function (result) {
        var compiledTemplate, template;
        template = this._properties.params.template || 'google_results';
        compiledTemplate = Handlebars.getTemplate(template);
        this._properties.response.target.innerHTML = compiledTemplate(result);
        return this.events.emit('results-rendered', result);
    };

    AjaxSearch.prototype.extend = function () {
        return this;
    };

    return AjaxSearch;

})();

GoogleSearch = (function (superClass) {
    extend(GoogleSearch, superClass);

    function GoogleSearch(data1, attr) {
        var config;
        this.data = data1;
        this.bindPagination = bind(this.bindPagination, this);
        this.extend = bind(this.extend, this);
        config = {
            _id: 'google',
            google: {
                baseUrl: "/?ACT=191"
            }
        };
        GoogleSearch.__super__.constructor.call(this, this.data, attr, config);
    }

    GoogleSearch.prototype.getName = function () {
        return 'GoogleSearch';
    };

    GoogleSearch.prototype.extend = function () {
        this.events.on('results-rendered', (function (_this) {
            return function (result) {
                _this.bindPagination(result);
                return _this.events.emit('query-changed');
            };
        })(this));
        return this;
    };

    GoogleSearch.prototype.bindPagination = function (result) {
        var bindNext, bindPrevious;
        bindPrevious = (function (_this) {
            return function () {
                var target;
                target = _this._properties.response.target.querySelectorAll('[data-search-previous]')[0];
                if (target != null) {
                    target.onclick = function (e) {
                        _this._properties.query.start = "start=" + result[0].pagination.previousPage[0].startIndex;
                        return _this.events.emit('search', _this._properties.query._search);
                    };
                }
                return _this;
            };
        })(this);
        if (result[0].pagination.previousPage) {
            bindPrevious();
        }
        bindNext = (function (_this) {
            return function () {
                var target;
                target = _this._properties.response.target.querySelectorAll('[data-search-next]')[0];
                if (target != null) {
                    target.onclick = function (e) {
                        _this._properties.query.start = "start=" + result[0].pagination.nextPage[0].startIndex;
                        return _this.events.emit('search', _this._properties.query._search);
                    };
                }
                return _this;
            };
        })(this);
        if (result[0].pagination.nextPage) {
            return bindNext();
        }
    };

    return GoogleSearch;

})(AjaxSearch);

if (typeof core !== "undefined" && core !== null) {
    core.addPlugin('GoogleSearch', GoogleSearch, '[data-google-search]');
}


/*
@class Audio

@author
  James E Baxley III
  NewSpring Church

@version 0.1

@note
  Handles interactions of audio players based on data- parameters
 */

Audio = (function () {
    function Audio(data1, attr) {
        var json, meta, params;
        this.data = data1;
        this.skipTo = bind(this.skipTo, this);
        this.bindPlayer = bind(this.bindPlayer, this);
        this.createPlayer = bind(this.createPlayer, this);
        params = this.data.attributes[attr].value.split(",");
        params = params.map(function (param) {
            return param.trim();
        });
        if (params.length > 3) {
            meta = params.splice(0, 2);
            json = params.join(",");
            params = meta.concat(json);
        }
        this._properties = {
            _id: params[0],
            target: this.data,
            audio: params[1],
            preload: params[2]
        };
        if (typeof EventEmitter !== "undefined" && EventEmitter !== null) {
            this.events = new EventEmitter();
        }
        this.createPlayer(this._properties.audio, this._properties.preload).bindPlayer();
    }

    Audio.prototype.createPlayer = function (audioFile, preload) {
        var audio;
        audio = document.createElement("audio");
        audio.src = audioFile;
        audio.preload = 'none';
        this._properties.target.parentNode.insertBefore(audio, this._properties.target);
        this._properties.target.parentNode.removeChild(this._properties.target);
        this._properties.target = audio;
        return this;
    };

    Audio.prototype.bindPlayer = function () {
        var player, settings;
        settings = {
            swfLocation: "//s3.amazonaws.com.ns.assets/javascript-dependencies/audiojs.swf",
            imageLocation: "//s3.amazonaws.com/ns.assets/javascript-dependencies/player-graphics.gif"
        };
        if (audiojs) {
            player = audiojs.create(this._properties.target, settings);
            return this._properties.player = player;
        }
    };

    Audio.prototype.skipTo = function (percent) {
        return this._properties.player.skipTo(percent);
    };

    return Audio;

})();

if (typeof core !== "undefined" && core !== null) {
    core.addPlugin("Audio", Audio, "[data-audio]");
}


/*

@class NewSpringBackgroundPlayer

@author
  James E Baxley III
  NewSpring Church

@version 0.9

@dependencies
  NewSpring.Utilities.js


  [todo] - add in namespacing following plugin architecture rules
 */

BackgroundPlayer = (function () {

/*
  Constructor function runs when object gets initialized
  
  @param {Element} Element to be used for creating video and image fallback
   */

    function BackgroundPlayer(data1, attr) {
        var debounce, json, meta, params, seeIfInView, videos;
        this.data = data1;
        this.setPositionOffset = bind(this.setPositionOffset, this);
        this.matchParentSize = bind(this.matchParentSize, this);
        this.testIfResized = bind(this.testIfResized, this);
        this.bindResize = bind(this.bindResize, this);
        this.shouldPlay = bind(this.shouldPlay, this);
        this.startPlaying = bind(this.startPlaying, this);
        this.setUpVideo = bind(this.setUpVideo, this);
        this.setUpImg = bind(this.setUpImg, this);
        this.setCSS = bind(this.setCSS, this);
        this.buildElement = bind(this.buildElement, this);
        this.determineDesiredPositioning = bind(this.determineDesiredPositioning, this);
        this.determineAssetToLoad = bind(this.determineAssetToLoad, this);
        this.getParentWidth = bind(this.getParentWidth, this);
        this.getParentHeight = bind(this.getParentHeight, this);
        if (this.data instanceof jQuery) {
            this.data = this.data.get(0);
        }
        params = this.data.attributes[attr].value.split(/[,](?=[^\]]*?(?:\[))/g);
        params = params.map(function (param) {
            return param.trim();
        });
        if (params.length > 3) {
            meta = params.splice(0, 2);
            json = params.join(',');
            params = meta.concat(json);
        }
        videos = params[1].replace(/[\[\]']+/g, '').split(',');
        videos = videos.map(function (param) {
            return param.trim();
        });
        this._properties = {
            _id: params[0],
            parent: this.data.parentElement,
            bg: {
                element: this.data,
                klass: this.data.className
            },
            videos: videos
        };

/*
    
    Check if element is in view
    If it is, then go to @determineAssetToLoad and remove listener
     */
        seeIfInView = (function (_this) {
            return function () {
                var callback;
                if (core.isElementInView(_this.data)) {
                    callback = function () {
                        if (core.isElementInView(_this.data)) {
                            window.removeEventListener('scroll', seeIfInView, false);
                            _this.determineAssetToLoad();
                            return false;
                        } else {

/*
              
              @todo write better way of handling scrolling past
               */
                            window.removeEventListener('scroll', seeIfInView, false);
                            return window.addEventListener('scroll', seeIfInView, false);
                        }
                    };
                    setTimeout(callback, 500);
                    return window.removeEventListener('scroll', seeIfInView, false);
                }
            };
        })(this);

/*
    
    Check to see if the element is in view before doing anything
    If not in view, bind resize to check and see when in view
    If in view then go to @determineAssetToLoad
     */
        if (core.isElementInView(this.data)) {
            this.determineAssetToLoad();
        } else {
            debounce = core.debounce(seeIfInView);
            window.addEventListener('scroll', seeIfInView, false);
        }
    }


/*
  
  @function getParentHeight()
  
  @return {Value} height of parent container
   */

    BackgroundPlayer.prototype.getParentHeight = function () {
        return this._properties.parent.clientHeight;
    };


/*
  
  @function getParentWidth()
  
  @return {Value} width of parent container
   */

    BackgroundPlayer.prototype.getParentWidth = function () {
        return this._properties.parent.clientWidth;
    };


/*
  
  @function determineAssetToLoad()
  
  @note
    Calls @determineDesiredPositioning with data type
    Calls @setUpImg if a mobile device
    Calls @setUpVideo if video is possible
  
  @chainable
   */

    BackgroundPlayer.prototype.determineAssetToLoad = function () {
        if (core.isMobile()) {

        } else {
            this.determineDesiredPositioning('video').setUpVideo();
        }
        return this;
    };


/*
  
  @function determineDesiredPositioning()
  
  @note
    Add positioning information from data attributes to @_properties object
  
  @chainable
   */

    BackgroundPlayer.prototype.determineDesiredPositioning = function (type) {
        var positioning;
        positioning = this._properties.bg.element.getAttribute("data-" + type + "-position");
        if (positioning != null) {
            positioning = positioning.split(",");
            if (positioning.length === 1) {
                this._properties.bg.xaxis = positioning[0].replace(/(^\s+|\s+$)/g, "");
                this._properties.bg.yaxis = positioning[0].replace(/(^\s+|\s+$)/g, "");
            } else {
                this._properties.bg.xaxis = positioning[0].replace(/(^\s+|\s+$)/g, "");
                this._properties.bg.yaxis = positioning[1].replace(/(^\s+|\s+$)/g, "");
            }
        } else {
            this._properties.bg.xaxis = "center";
            this._properties.bg.yaxis = "center";
        }
        return this;
    };


/*
  
  @function buildElement()
  
  @param {String} Kind of element to build (img or video)
  
  @return {Element} Built oject or video
  
  @note
    Adds element to the DOM
   */

    BackgroundPlayer.prototype.buildElement = function (type) {
        var asset, j, len, ref, source, video;
        if (this._properties.parent.style.position = "") {
            this._properties.parent.style.position = "relative";
        }
        asset = document.createElement(type);
        if (type !== "video") {
            asset.src = this._properties.bg.element.getAttribute("data-background-" + type);
        } else {
            ref = this._properties.videos;
            for (j = 0, len = ref.length; j < len; j++) {
                video = ref[j];
                source = document.createElement("source");
                source.src = video.trim();
                source.type = "video/" + (video.substr(video.lastIndexOf('.') + 1));
                asset.appendChild(source);
            }
        }
        this._properties.bg.element.klass = this._properties.bg.element.className;
        asset.className = this._properties.bg.element.klass;
        this._properties.parent.insertBefore(asset, this._properties.bg.element);
        this._properties.bg.root = this._properties.bg.element;
        this._properties.bg.element = asset;
        return asset;
    };


/*
  
  @function setCSS()
  
  @note
    Makes sure asset is fully filling container element
    Also makes sure video is in background with z-index
  
  @chainable
   */

    BackgroundPlayer.prototype.setCSS = function () {
        this._properties.parent.style.overflow = "hidden";
        this._properties.bg.element.style.display = "block";
        this._properties.bg.element.style.position = "absolute";
        this._properties.bg.element.style.objectFit = "cover";
        this._properties.bg.element.style.height = "auto";
        this._properties.bg.element.style.minWidth = "100%";
        this._properties.bg.element.style.minHeight = "100%";
        this._properties.bg.element.style.zIndex = "-5px";
        this._properties.bg.element.style.top = "0";
        this._properties.bg.element.style.bottom = "0";
        this._properties.bg.element.style.left = "0";
        this._properties.bg.element.style.right = "0";
        if (core.isMobile()) {
            this._properties.bg.element.style.width = "auto";
        }
        return this;
    };


/*
  
  @function setUpImg()
  
  @note
    sets up img for mobile devices and waits until it is loaded before moving on
  
  @chainable
   */

    BackgroundPlayer.prototype.setUpImg = function () {
        var img, img_src, startSizing;
        img_src = this._properties.bg.element.getAttribute("data-background-img");
        if (img_src != null) {
            img = this.buildElement('img');

/*
      
      @function startSizing()
      
      @note
        fires @setCSS to ensure styles
        fires @matchParentSize for inital size
        fires @bindResize for debounce based resizing
      
      @chainable
       */
            startSizing = (function (_this) {
                return function () {
                    _this.setCSS().matchParentSize().bindResize();
                    img.removeEventListener('load', startSizing, false);
                    _this._properties.parent.removeChild(_this._properties.bg.root);
                    return _this;
                };
            })(this);
            img.addEventListener('load', startSizing, false);
        }
        return this;
    };


/*
  
  @function setUpVideo()
  
  @note
    sets up video for non-mobile devices and waits until it is loaded before moving on
  
  @chainable
   */

    BackgroundPlayer.prototype.setUpVideo = function () {
        var startSizing, video;
        video = this.buildElement('video');
        video.style.display = "none";

/*
    
    @function startPlaying()
    
    @note
      fires @setCSS to ensure styles
      fires @matchParentSize for inital size
      fires @bindResize for debounce based resizing
      fires @startPlaying to play video
    
    @chainable
     */
        startSizing = (function (_this) {
            return function () {
                _this.setCSS().matchParentSize().bindResize().startPlaying();
                video.removeEventListener('canplay', startSizing, false);
                _this._properties.parent.removeChild(_this._properties.bg.root);
                return _this;
            };
        })(this);
        return video.addEventListener('canplay', startSizing, false);
    };


/*
  
  @function startPlaying()
  
  @note
    puts video into loop
    mutes video
    starts video playing
  
  @chainable
   */

    BackgroundPlayer.prototype.startPlaying = function () {
        var debounce;
        this._properties.bg.element.loop = true;
        this._properties.bg.element.volume = 0;
        if (this._properties.bg.element.paused) {
            this._properties.bg.element.play();
        }
        debounce = core.debounce(this.shouldPlay);
        window.addEventListener('scroll', debounce, false);
        return this;
    };


/*
  
  @function shouldPlay()
  
  @note
    checks to see if video is in view, if it is then it plays, otherwise it pauses video
  
  @chainable
   */

    BackgroundPlayer.prototype.shouldPlay = function () {
        if (core.isElementInView(this._properties.bg.element)) {
            if (this._properties.bg.element.paused) {
                this._properties.bg.element.play();
            }
        } else {
            if (!this._properties.bg.element.paused) {
                this._properties.bg.element.pause();
            }
        }
        return this;
    };


/*
  
  @function bindResize()
  
  @note
    uses debounce and resize binding to maintain sizing
  
  @chainable
   */

    BackgroundPlayer.prototype.bindResize = function (type) {
        var debounce;
        debounce = core.debounce(this.testIfResized);
        window.addEventListener("resize", debounce, false);
        return this;
    };


/*
  
  @function testIfResized()
  
  @note
    checks to see if resize event is genuine
  
  @chainable
   */

    BackgroundPlayer.prototype.testIfResized = function () {
        if (this._properties.wid != null) {
            if (this._properties.wid = window.innerWidth) {
                this.setPositionOffset();
            } else {
                this.matchParentSize();
            }
        } else {
            this.matchParentSize();
        }
        return this;
    };


/*
  
  @function matchParentSize()
  
  @note
    matches element to parent size while keeping original assets aspect ratio
  
  @chainable
   */

    BackgroundPlayer.prototype.matchParentSize = function () {
        var aspectRatio, elementHeight, elementWidth, parentHeight, parentWidth, wide;
        parentHeight = this.getParentHeight();
        parentWidth = this.getParentWidth();

/*
    
    Determine size of intended asset while load is happening
     */
        if (this._properties.bg.element.videoHeight != null) {
            elementHeight = this._properties.bg.element.videoHeight;
            elementWidth = this._properties.bg.element.videoWidth;
        } else {
            elementHeight = this._properties.bg.element.naturalHeight;
            elementWidth = this._properties.bg.element.naturalWidth;
        }
        aspectRatio = elementWidth / elementHeight;
        wide = aspectRatio <= (parentWidth / parentHeight);
        if (wide) {
            this._properties.bg.element.width = parentWidth;
            this._properties.bg.element.height = (parentWidth * elementHeight) / elementWidth;
        } else {
            this._properties.bg.element.height = parentHeight;
            this._properties.bg.element.width = (parentHeight * elementWidth) / elementHeight;
        }
        if (core.isMobile()) {
            this._properties.wid = window.innerWidth;
        }
        this.setPositionOffset();
        return this;
    };


/*
  
  @function setPositionOffset()
  
  @note
    Uses margin left and margin top to handle offset
  
  @chainable
   */

    BackgroundPlayer.prototype.setPositionOffset = function () {
        var parentHeight, parentWidth;
        parentHeight = this.getParentHeight();
        parentWidth = this.getParentWidth();
        switch (this._properties.bg.xaxis) {
        case "left":
            this._properties.bg.element.style.marginLeft = 0;
            break;
        case "right":
            this._properties.bg.element.style.marginLeft = (-(this._properties.bg.element.width - parentWidth)) + "px";
            break;
        default:
            this._properties.bg.element.style.marginLeft = (-((Math.abs(this._properties.bg.element.width - parentWidth)) / 2)) + "px";
        }
        switch (this._properties.bg.yaxis) {
        case "top":
            this._properties.bg.element.style.marginTop = 0;
            break;
        case "bottom":
            this._properties.bg.element.style.marginTop = (-(this._properties.bg.element.height - parentHeight)) + "px";
            break;
        default:
            this._properties.bg.element.style.marginTop = (-((this._properties.bg.element.height - parentHeight) / 2)) + "px";
        }
        return this;
    };

    return BackgroundPlayer;

})();

if (typeof core !== "undefined" && core !== null) {
    core.addPlugin('BackgroundPlayer', BackgroundPlayer, '[data-background-video]');
}


/*
@class Checkout

@author
  James E Baxley III
  NewSpring Church

@version 0.1

@note
  Handles interactions of checkouts with Cartthrob based on data- parameters
 */

Checkout = (function () {
    function Checkout(data1, attr) {
        var e, params;
        this.data = data1;
        this.clearCart = bind(this.clearCart, this);
        this.mapFields = bind(this.mapFields, this);
        this.loadModal = bind(this.loadModal, this);
        this.submitForm = bind(this.submitForm, this);
        this.cleanInstant = bind(this.cleanInstant, this);
        this.processInstant = bind(this.processInstant, this);
        this.bindEvents = bind(this.bindEvents, this);
        this.bindClick = bind(this.bindClick, this);
        params = this.data.attributes[attr].value.split(',');
        params = params.map(function (param) {
            return param.trim();
        });
        this._properties = {
            attr: attr,
            _id: this.data.href,
            entry_id: params[1],
            modal: params[2],
            target: this.data,
            triggers: {},
            mappedFields: (function () {
                try {
                    return JSON.parse(this.data.dataset.checkoutInfo);
                } catch (_error) {
                    e = _error;
                    return false;
                }
            }).call(this),
            form: document.getElementById(params[1]),
            instant: params[3] === 'download' ? true : false
        };
        if (typeof EventEmitter !== "undefined" && EventEmitter !== null) {
            this.events = new EventEmitter();
        }
        this.bindClick().bindEvents();
    }

    Checkout.prototype.bindClick = function () {
        var checkout;
        checkout = (function (_this) {
            return function (e) {
                var a;
                if (!_this._properties.instant) {
                    _this._properties.originalText = _this._properties.target.innerText;
                    _this._properties.target.innerHTML = 'Loading...<span class="icon icon--loading"></span>';
                    core.addClass(_this._properties.target, 'btn--icon');
                }
                if (_this._properties.instant) {
                    a = document.createElement("a");
                    if (typeof a.download === "undefined") {
                        e.preventDefault();
                        window.open(_this._properties._id, '_blank');
                    }
                } else {
                    e.preventDefault();
                }
                _this.clearCart();
            };
        })(this);
        this._properties.target.addEventListener('click', checkout, false);
        return this;
    };

    Checkout.prototype.bindEvents = function () {
        this.events.on('cleared', (function (_this) {
            return function () {
                return _this.submitForm();
            };
        })(this));
        return this.events.on('added', (function (_this) {
            return function (data) {
                if (_this._properties.instant) {
                    _this.processInstant();
                    return _this.loadModal(true);
                } else {
                    return _this.loadModal();
                }
            };
        })(this));
    };

    Checkout.prototype.processInstant = function () {
        return this.cleanInstant();
    };

    Checkout.prototype.cleanInstant = function () {
        var item, j, len, ref, results1;
        ref = core.flattenObject(core['checkout']);
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
            item = ref[j];
            if (item._properties._id !== this._properties._id) {
                results1.push(delete core['checkout'][item._properties._id]);
            } else {
                results1.push(void 0);
            }
        }
        return results1;
    };

    Checkout.prototype.submitForm = function () {
        var plugin;
        plugin = this;
        $(this._properties.form).ajaxForm({
            dataType: "json",
            success: function (data) {
                if (data.success) {
                    plugin.events.emit('added', data);
                } else {

                }
            }
        });
        if (typeof this._properties.form.submit === "function") {
            return this._properties.form.submit();
        } else {
            return this._properties.form.submit.click();
        }
    };

    Checkout.prototype.loadModal = function (hidden) {
        var Modal, delay, existingModal, modalName, removeLoading, tmpl;
        existingModal = document.querySelectorAll('[data-modal="' + this._properties.modal + '"]')[0];
        if (existingModal) {
            existingModal.parentNode.removeChild(existingModal);
        }
        Modal = core['plugins']['Modal'];
        modalName = (typeof modal !== "undefined" && modal !== null) ? modal : this._properties.modal;
        if (Modal != null) {
            if (core.modal != null) {
                core.modal[modalName] = void 0;
                tmpl = modalName;
                core.modal[tmpl] = new Modal.model(tmpl, 'data-modal-open', "preload");
            } else {
                core.modal = {};
                tmpl = modalName;
                core.modal[tmpl] = new Modal.model(tmpl, 'data-modal-open', "preload");
            }
        }
        if (!hidden) {
            core.modal[modalName].toggleModal();
        }
        this.mapFields();
        removeLoading = (function (_this) {
            return function () {
                _this._properties.target.innerHTML = '';
                _this._properties.target.innerText = _this._properties.originalText;
                _this._properties.target.originalText = '';
                return core.removeClass(_this._properties.target, 'btn--icon');
            };
        })(this);
        if (!this._properties.instant) {
            delay = setTimeout(removeLoading, 5000);
        }
        return this;
    };

    Checkout.prototype.mapFields = function () {
        var field, form, j, len, mapped, mappedField;
        if (this._properties.mappedFields) {
            core.mappedFields = this._properties.mappedFields;
            form = core.modal[this._properties.modal]._properties.modal;
            for (field in this._properties.mappedFields) {
                mappedField = form.querySelectorAll('[name="' + field + '"]');
                for (j = 0, len = mappedField.length; j < len; j++) {
                    mapped = mappedField[j];
                    mapped.value = this._properties.mappedFields[field];
                }
            }
        }
        return this;
    };

    Checkout.prototype.clearCart = function () {
        var request;
        request = new XMLHttpRequest();
        request.open("GET", "/checkout/clearcart", true);
        request.onload = (function (_this) {
            return function () {
                if (request.status >= 200 && request.status < 400) {
                    _this.events.emit('cleared');
                }
            };
        })(this);
        request.onerror = function () {
            return console.log('error has occured');
        };
        return request.send();
    };

    return Checkout;

})();

if (typeof core !== "undefined" && core !== null) {
    core.addPlugin('Checkout', Checkout, '[data-checkout]');
}


/*
@class FullScreen

@author
  James E Baxley III
  NewSpring Church

@version 0.1

@note
  used to turn an element into a full screen element
  Resize is bound
 */

FullScreen = (function () {
    function FullScreen(data1, attr) {
        var params;
        this.data = data1;
        this.bindResize = bind(this.bindResize, this);
        this.expandElement = bind(this.expandElement, this);
        if (this.data instanceof jQuery) {
            this.data = this.data.get(0);
        }
        params = this.data.attributes[attr].value.split(',');
        params = params.map(function (param) {
            return param.trim();
        });
        this._properties = {
            target: this.data,
            height: params[1],
            width: params[2],
            id: params[0]
        };
        this.bindResize(this._properties.target);
    }

    FullScreen.prototype.expandElement = function () {
        var acutalHeight, windowHeight, windowWidth;
        windowHeight = window.innerHeight;
        windowWidth = window.innerWidth;
        if (this._properties.height !== undefined) {
            acutalHeight = windowHeight - this._properties.height;
        } else {
            acutalHeight = windowHeight;
        }
        if (this._properties.width !== 'false') {
            this._properties.target.style.width = windowWidth + "px";
        }
        if (this._properties.height !== 'false') {
            this._properties.target.style.height = acutalHeight + "px";
            if (this._properties.target.tagName === 'IFRAME') {
                this._properties.target.height = acutalHeight;
            }
        }
        return this;
    };

    FullScreen.prototype.bindResize = function (element) {
        var debounce;
        debounce = null;
        if (debounce == null) {
            debounce = new Debouncer(this.expandElement);
        }
        window.addEventListener("resize", debounce, false);
        return this.expandElement();
    };

    return FullScreen;

})();

if (typeof core !== "undefined" && core !== null) {
    core.addPlugin('FullScreen', FullScreen, '[data-fullscreen]');
}


/*
@class Googleapis, Geolocation

@author
  James E Baxley III
  NewSpring Church

@version 0.1

@note
  Googleapis required to initialize Google maps
  Geolocation renders map view of data parameters
 */

Googleapis = (function () {
    function Googleapis(data1) {
        this.data = data1;
        this.getMarkers = bind(this.getMarkers, this);
        this.initialize = bind(this.initialize, this);
        this._properties = {
            scripts: {
                googleapis: "https://maps.googleapis.com/maps/api/js?v=3.exp" + "&callback=googleapis.initialize"
            },
            img: "//s3.amazonaws.com/ns.images/newspring/locations/newspring.mapmarker.png",
            maps: [],
            styles: {
                multi: [{
                    featureType: "road",
                    elementType: "geometry",
                    stylers: [{
                        visibility: "off"
                    }]
                },
                {
                    featureType: "poi",
                    elementType: "geometry",
                    stylers: [{
                        visibility: "off"
                    }]
                },
                {
                    featureType: "landscape",
                    elementType: "geometry",
                    stylers: [{
                        color: "#fffffa"
                    }]
                },
                {
                    featureType: "water",
                    stylers: [{
                        lightness: 50
                    }]
                },
                {
                    featureType: "road",
                    elementType: "labels",
                    stylers: [{
                        visibility: "off"
                    }]
                },
                {
                    featureType: "transit",
                    stylers: [{
                        visibility: "off"
                    }]
                },
                {
                    featureType: "administrative",
                    elementType: "geometry",
                    stylers: [{
                        lightness: 40
                    }]
                }],
                network: [{
                    featureType: "water",
                    elementType: "geometry",
                    stylers: [{
                        color: "#a2daf2"
                    }]
                },
                {
                    featureType: "landscape.man_made",
                    elementType: "geometry",
                    stylers: [{
                        color: "#f7f1df"
                    }]
                },
                {
                    featureType: "landscape.natural",
                    elementType: "geometry",
                    stylers: [{
                        color: "#f7f1df"
                    }]
                },
                {
                    featureType: "landscape.natural.terrain",
                    elementType: "geometry",
                    stylers: [{
                        visibility: "off"
                    }]
                },
                {
                    featureType: "poi.park",
                    elementType: "geometry",
                    stylers: [{
                        color: "#f7f1df"
                    }]
                },
                {
                    featureType: "poi",
                    elementType: "labels",
                    stylers: [{
                        visibility: "off"
                    }]
                },
                {
                    featureType: "poi.medical",
                    elementType: "geometry",
                    stylers: [{
                        color: "#fbd3da"
                    }]
                },
                {
                    featureType: "poi.business",
                    stylers: [{
                        visibility: "off"
                    }]
                },
                {
                    featureType: "road",
                    elementType: "geometry.stroke",
                    stylers: [{
                        visibility: "off"
                    }]
                },
                {
                    featureType: "road.highway",
                    elementType: "geometry.fill",
                    stylers: [{
                        color: "#ffe15f"
                    }]
                },
                {
                    featureType: "road.highway",
                    elementType: "geometry.stroke",
                    stylers: [{
                        color: "#efd151"
                    }]
                },
                {
                    featureType: "road.arterial",
                    elementType: "geometry.fill",
                    stylers: [{
                        color: "#ffffff"
                    }]
                },
                {
                    featureType: "road.local",
                    elementType: "geometry.fill",
                    stylers: [{
                        color: "black"
                    }]
                },
                {
                    featureType: "transit.station.airport",
                    elementType: "geometry.fill",
                    stylers: [{
                        color: "#cfb2db"
                    }]
                }]
            }
        };
        this.loadScript();
    }

    Googleapis.prototype.initialize = function () {
        return this.getMarkers();
    };

    Googleapis.prototype.getMarkers = function () {
        var j, len, location, map, ref, results1;
        ref = core.flattenObject(core.geolocation);
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
            location = ref[j];
            map = location.createMap();
            results1.push(this._properties.maps.push(map));
        }
        return results1;
    };

    Googleapis.prototype.loadScript = function () {
        var script, scripts, scrpt;
        script = document.createElement("script");
        script.src = this._properties.scripts['googleapis'];
        scripts = core.flatten(document.getElementsByTagName("script"));
        scrpt = scripts.filter((function (_this) {
            return function (attr) {
                if ((attr.attributes["src"] != null) && (attr.attributes["src"].value != null)) {
                    return attr.attributes["src"].value === _this._properties.scripts['googleapis'];
                }
            };
        })(this));
        if (!(scrpt.length > 0)) {
            document.head.appendChild(script);
        }
        return this;
    };

    return Googleapis;

})();

Geolocation = (function () {

/*
  Constructor function runs when object gets initialized
  
  @param {Object} options for setting up the class
   */

    function Geolocation(data1, attr) {
        var choosenLocations, e, json, locations, meta, params;
        this.data = data1;
        this.calculateDistance = bind(this.calculateDistance, this);
        this.getUserLocation = bind(this.getUserLocation, this);
        this.findClosest = bind(this.findClosest, this);
        this.bindZoom = bind(this.bindZoom, this);
        this.bindResize = bind(this.bindResize, this);
        this.fitBounds = bind(this.fitBounds, this);
        this.fitCenter = bind(this.fitCenter, this);
        this.setCenter = bind(this.setCenter, this);
        this.locationClicked = bind(this.locationClicked, this);
        this.createMarker = bind(this.createMarker, this);
        this.createNewMarker = bind(this.createNewMarker, this);
        this.createMap = bind(this.createMap, this);
        this.bindEvents = bind(this.bindEvents, this);
        if (this.data instanceof jQuery) {
            this.data = this.data.get(0);
        }
        params = this.data.attributes[attr].value.split(/[,](?=[^\]]*?(?:\[))/g);
        if (params.length > 2) {
            meta = params.splice(0, 2);
            json = params.join(',');
            params = meta.concat(json);
        }
        params = params.map(function (param) {
            return param.trim();
        });
        choosenLocations = params[1].replace(/[\[\]']+/g, '').split(',');
        choosenLocations = choosenLocations.map(function (param) {
            return param.trim();
        });
        if (typeof choosenLocations === 'string') {
            choosenLocations = [choosenLocations];
        }
        locations = (function () {
            try {
                return JSON.parse(params[2]);
            } catch (_error) {
                e = _error;
                return console.log(e);
            }
        })();
        if (choosenLocations[0] !== 'all') {
            locations = locations.filter((function (_this) {
                return function (location) {
                    var campus, j, len;
                    for (j = 0, len = choosenLocations.length; j < len; j++) {
                        campus = choosenLocations[j];
                        if (location._id.toLowerCase().replace(' ', '').indexOf(campus.toLowerCase().replace(' ', '')) > -1) {
                            return true;
                        } else {
                            false;
                        }
                    }
                };
            })(this));
        }
        this._properties = {
            _id: params[0],
            target: this.data,
            location: choosenLocations,
            locations: locations,
            map: {},
            markers: [],
            mapOptions: {},
            multi: false,
            attr: attr
        };
        if (this._properties.location[0] === 'all' || this._properties.location.length > 1) {
            this._properties.multi = true;
        }
        if (typeof EventEmitter !== "undefined" && EventEmitter !== null) {
            this.events = new EventEmitter();
        }
        this.bindEvents();
    }

    Geolocation.prototype.getName = function () {
        return 'Geolocation';
    };

    Geolocation.prototype.bindEvents = function () {
        this.events.on('campus-found', (function (_this) {
            return function (campus) {
                var j, len, ref, trigger;
                ref = _this._properties.findLocation;
                for (j = 0, len = ref.length; j < len; j++) {
                    trigger = ref[j];
                    core.removeClass(trigger, 'btn--icon btn--filled');
                    trigger.innerHTML = trigger.dataset.originalText;
                }
                return window.location.href = campus.url;
            };
        })(this));
        return this.events.on('finding-closest', (function (_this) {
            return function () {
                var j, len, ref, results1, trigger;
                ref = _this._properties.findLocation;
                results1 = [];
                for (j = 0, len = ref.length; j < len; j++) {
                    trigger = ref[j];
                    trigger.dataset.originalText = trigger.innerText;
                    trigger.innerHTML = 'Loading...<span class="icon icon--loading"></span>';
                    results1.push(core.addClass(trigger, 'btn--icon btn--filled'));
                }
                return results1;
            };
        })(this));
    };

    Geolocation.prototype.createMap = function () {
        var center, j, len, location, ref, styles, zoom;
        zoom = this._properties.multi ? 8 : 15;
        center = !this._properties.multi ? center = new google.maps.LatLng(this._properties.locations[0].lat, this._properties.locations[0].lng) : center = null;
        if (this._properties.multi) {
            styles = googleapis._properties.styles.multi;
        }
        if (window.location.host.split('.')[0] === 'network') {
            zoom = 6;
            styles = googleapis._properties.styles.network;
        }
        this._properties.mapOptions = {
            zoom: zoom,
            scrollwheel: false,
            draggable: !core.isMobile(),
            center: center,
            disableDefaultUI: true,
            styles: styles
        };
        this._properties.map = new google.maps.Map(this._properties.target, this._properties.mapOptions);
        if (this._properties.multi) {
            ref = this._properties.locations;
            for (j = 0, len = ref.length; j < len; j++) {
                location = ref[j];
                this.createMarker(location);
            }
            this.fitBounds().bindResize(this.fitBounds);
        } else {
            this.createMarker(this._properties.locations[0]);
            this.setCenter().fitCenter().bindResize(this.fitCenter);
            google.maps.event.addDomListener(this._properties.map, 'idle', (function (_this) {
                return function () {
                    return _this.setCenter();
                };
            })(this));
        }
        this.bindZoom();
        if (this._properties.multi) {
            this.findClosest();
        }
        this._properties.service = new google.maps.DistanceMatrixService();
        this._properties.geocoder = new google.maps.Geocoder();
        return this._properties.map;
    };

    Geolocation.prototype.createNewMarker = function (location) {
        if (typeof location === 'string') {
            this._properties.geocoder.geocode({
                "address": location
            }, (function (_this) {
                return function (results, status) {
                    var campusLatLng;
                    if (status === "OK") {
                        campusLatLng = {
                            lat: results[0].geometry.location.lat(),
                            lng: results[0].geometry.location.lng()
                        };
                        return _this.createMarker(campusLatLng);
                    }
                };
            })(this));
        } else {
            this.createMarker(location);
        }
        return this;
    };

    Geolocation.prototype.createMarker = function (location) {
        var campusLatLng, compiledTemplate, img, infoWindow, marker, url;
        if (typeof google !== "undefined" && google !== null) {
            campusLatLng = new google.maps.LatLng(location.lat, location.lng);
            img = (location.img != null) ? location.img : googleapis._properties.img;
            url = location.url;
            compiledTemplate = Handlebars.getTemplate('locations_popup');
            infoWindow = new google.maps.InfoWindow({
                content: compiledTemplate(location)
            });
            marker = new google.maps.Marker({
                _id: location._id,
                position: campusLatLng,
                map: this._properties.map,
                title: location.campus,
                url: url,
                icon: img,
                zIndex: location.count,
                infoWindow: infoWindow
            });
            google.maps.event.addListener(marker, 'click', this.locationClicked(marker));
            this._properties.markers.push(marker);
        }
        return this;
    };

    Geolocation.prototype.locationClicked = function (marker) {
        return (function (_this) {
            return function () {
                return window.location.href = marker.url;
            };
        })(this);
    };

    Geolocation.prototype.setCenter = function () {
        this._properties.center = this._properties.map.getCenter();
        return this;
    };

    Geolocation.prototype.fitCenter = function () {
        this._properties.map.setCenter(this._properties.center);
        return this;
    };

    Geolocation.prototype.fitBounds = function () {
        var bounds, j, len, marker, ref;
        bounds = new google.maps.LatLngBounds();
        ref = this._properties.markers;
        for (j = 0, len = ref.length; j < len; j++) {
            marker = ref[j];
            bounds.extend(marker.getPosition());
        }
        this._properties.map.fitBounds(bounds);
        return this;
    };

    Geolocation.prototype.bindResize = function (cb) {
        var debounce;
        debounce = core.debounce(cb);
        window.addEventListener('resize', debounce, false);
        return this;
    };

    Geolocation.prototype.bindZoom = function () {
        var zoom, zoomIn, zoomOut;
        zoomIn = document.querySelectorAll('[' + this._properties.attr + '-zoom-in="' + this._properties._id + '"]')[0];
        zoomOut = document.querySelectorAll('[' + this._properties.attr + '-zoom-out="' + this._properties._id + '"]')[0];
        zoom = this._properties.map.getZoom();
        google.maps.event.addDomListener(zoomIn, 'click', (function (_this) {
            return function () {
                zoom++;
                return _this._properties.map.setZoom(zoom);
            };
        })(this));
        google.maps.event.addDomListener(zoomOut, 'click', (function (_this) {
            return function () {
                zoom--;
                return _this._properties.map.setZoom(zoom);
            };
        })(this));
        return this;
    };

    Geolocation.prototype.findClosest = function () {
        var findClosest, j, len, trigger;
        findClosest = document.querySelectorAll('[' + this._properties.attr + '-closest="' + this._properties._id + '"]');
        this._properties.findLocation = findClosest;
        if (google) {
            for (j = 0, len = findClosest.length; j < len; j++) {
                trigger = findClosest[j];
                if (trigger.tagName === "INPUT") {
                    google.maps.event.addDomListener(trigger, 'blur', (function (_this) {
                        return function () {
                            _this.events.emit('finding-closest');
                            return _this.getUserLocation([trigger.value]);
                        };
                    })(this));
                    google.maps.event.addDomListener(trigger, 'keyup', (function (_this) {
                        return function (e) {
                            if (e.keyCode === 13) {
                                _this.events.emit('finding-closest');
                                return _this.getUserLocation([trigger.value]);
                            }
                        };
                    })(this));
                } else {
                    google.maps.event.addDomListener(trigger, 'click', (function (_this) {
                        return function () {
                            _this.events.emit('finding-closest');
                            return _this.getUserLocation();
                        };
                    })(this));
                }
            }
        }
        return this;
    };

    Geolocation.prototype.getUserLocation = function (location) {
        var callback, failure, returned, saveLocation, timeout;
        returned = false;
        saveLocation = (function (_this) {
            return function (position) {
                returned = true;
                _this._properties.userLocation = {
                    lat: position.coords.latitude,
                    lng: position.coords.longitude,
                    location: [new google.maps.LatLng(position.coords.latitude, position.coords.longitude)]
                };
                return _this.calculateDistance(_this._properties.userLocation.location);
            };
        })(this);
        failure = (function (_this) {
            return function () {
                var j, len, ref, results1, trigger;
                returned = true;
                ref = _this._properties.findLocation;
                results1 = [];
                for (j = 0, len = ref.length; j < len; j++) {
                    trigger = ref[j];
                    core.removeClass(trigger, 'btn--icon btn--filled');
                    results1.push(trigger.innerHTML = 'Location services unavailable');
                }
                return results1;
            };
        })(this);
        if (location) {
            this._properties.userLocation = {};
            return this.calculateDistance(location);
        } else {
            callback = function () {
                failure();
                return false;
            };
            timeout = setTimeout(callback, 15000);
            if (navigator.geolocation) {
                return navigator.geolocation.getCurrentPosition(function (position) {
                    clearTimeout(timeout);
                    return saveLocation(position);
                }, function () {
                    clearTimeout(timeout);
                    return failure();
                });
            }
        }
    };

    Geolocation.prototype.calculateDistance = function (location) {
        var cb;
        cb = (function (_this) {
            return function (response, status) {
                var distance, j, len, ref, results1, sorted;
                if (status === "OK") {
                    sorted = response.rows[0].elements.slice();
                    sorted.sort(function (a, b) {
                        if (a.duration.value < b.duration.value) {
                            return -1;
                        }
                        if (a.duration.value > b.duration.value) {
                            return 1;
                        }
                        return 0;
                    });
                    ref = response.rows[0].elements;
                    results1 = [];
                    for (j = 0, len = ref.length; j < len; j++) {
                        distance = ref[j];
                        if (distance.duration.value === sorted[0].duration.value) {
                            _this._properties.userLocation.closestCampus = _this._properties.locations[_i];
                            results1.push(_this.events.emit('campus-found', _this._properties.locations[_i]));
                        } else {
                            results1.push(void 0);
                        }
                    }
                    return results1;
                }
            };
        })(this);
        return this._properties.service.getDistanceMatrix({
            origins: location,
            destinations: this._properties.locations,
            travelMode: google.maps.TravelMode.DRIVING,
            unitSystem: google.maps.UnitSystem.IMPERIAL,
            durationInTraffic: true,
            avoidHighways: false,
            avoidTolls: false
        }, cb);
    };

    return Geolocation;

})();

if (typeof core !== "undefined" && core !== null) {
    callback = function () {
        return window.googleapis = new Googleapis();
    };
    core.addPlugin('Geolocation', Geolocation, '[data-geolocation]', callback);
}


/*
@class Modal

@author
  James E Baxley III
  NewSpring Church

@version 0.1

@note
 */

Modal = (function () {
    function Modal(data1, attr, toggle) {
        var id, params;
        this.data = data1;
        this.bindClose = bind(this.bindClose, this);
        this.bindOpen = bind(this.bindOpen, this);
        this.toggleModal = bind(this.toggleModal, this);
        this.createModal = bind(this.createModal, this);
        this.getModal = bind(this.getModal, this);
        if (this.data instanceof jQuery) {
            this.data = this.data.get(0);
        }
        if (typeof this.data !== 'string') {
            params = this.data.attributes[attr].value.split(',');
            params = params.map(function (param) {
                return param.trim();
            });
            id = params[0];
        } else {
            id = this.data;
        }
        this._properties = {
            _id: id,
            triggers: document.querySelectorAll('[' + attr + '*="' + id + '"]'),
            "class": params != null ? params[1] : void 0,
            preload: params != null ? params[2] : void 0
        };
        if (typeof EventEmitter !== "undefined" && EventEmitter !== null) {
            this.events = new EventEmitter();
        }
        if (this._properties.preload || toggle === "preload") {
            this.getModal();
        }
        if (typeof this.data !== 'string') {
            this.bindOpen();
        }
    }

    Modal.prototype.getModal = function (show) {
        var ajax, compiledTemplate, data, modal;
        modal = document.querySelectorAll('[data-modal="' + this._properties._id + '"]')[0];
        if (!modal) {
            this._properties.inDOM = false;
            compiledTemplate = Handlebars.getTemplate(this._properties._id);
            modal = document.createElement('div');
            if (this._properties["class"] != null) {
                core.addClass(modal, this._properties["class"]);
            }
            core.addClass(modal, 'modal');
            modal.setAttribute('data-modal', this._properties._id);
            data = {};
            if (this._properties.triggers[0] != null) {
                if (this._properties.triggers[0].attributes['data-modal-content']) {
                    data = JSON.parse(this._properties.triggers[0].attributes['data-modal-content'].value);
                }
            }
            if (typeof compiledTemplate === 'function') {
                modal.innerHTML = compiledTemplate(data);
                this.createModal(modal);
            } else {
                ajax = new XMLHttpRequest();
                ajax.onreadystatechange = (function (_this) {
                    return function () {
                        if (ajax.readyState !== 4 || ajax.status !== 200) {
                            return;
                        }
                        modal.innerHTML = ajax.response;
                        return _this.createModal(modal, show);
                    };
                })(this);
                ajax.open("GET", this._properties._id, false);
                ajax.send();
            }
        } else {
            this._properties.inDOM = true;
            if (this._properties.modal == null) {
                this._properties.modal = modal;
                this.bindClose();
            }
        }
        return this;
    };

    Modal.prototype.toggleClasses = function (modal) {
        var html, panel;
        core.toggleClass(modal, "modal--active");
        html = document.getElementsByTagName("html")[0];
        core.toggleClass(html, "modal--opened");
        panel = document.querySelectorAll('[data-panel]')[0];
        return core.toggleClass(panel, "panel--active");
    };

    Modal.prototype.createModal = function (modal, show) {
        this._properties.modal = modal;
        this.bindClose();
        if (!this._properties.inDOM) {
            document.getElementsByTagName('body')[0].appendChild(this._properties.modal);
            core.updateModels(this._properties.modal);
            this.events.emit('added', this._properties.modal);
            this._properties.inDOM = true;
            if (show) {
                return this.toggleModal();
            }
        }
    };

    Modal.prototype.toggleModal = function () {
        if (this._properties.modal === undefined) {
            this.getModal(true);
        } else {
            this.toggleClasses(this._properties.modal);
            if (!core.hasClass(this._properties.modal, 'modal--active')) {
                this.events.emit('close', this._properties.modal);
            } else {
                this.events.emit('open', this._properties.modal);
            }
        }
        return this;
    };

    Modal.prototype.bindOpen = function () {
        var click, j, len, ref, trigger;
        ref = this._properties.triggers;
        for (j = 0, len = ref.length; j < len; j++) {
            trigger = ref[j];
            click = (function (_this) {
                return function (e) {
                    e.preventDefault();
                    if (_this._properties.modal == null) {
                        _this.getModal();
                    }
                    return _this.toggleModal();
                };
            })(this);
            trigger.addEventListener('click', click, false);
        }
        return this;
    };

    Modal.prototype.bindClose = function () {
        var btn, j, len, ref;
        this.closeBtns = this._properties.modal.querySelectorAll('[data-modal-close="' + this._properties._id + '"]');
        if (this.closeBtns) {
            ref = this.closeBtns;
            for (j = 0, len = ref.length; j < len; j++) {
                btn = ref[j];
                btn.addEventListener("click", this.toggleModal, false);
            }
        }
        return this;
    };

    return Modal;

})();

if (typeof core !== "undefined" && core !== null) {
    core.addPlugin('Modal', Modal, '[data-modal-open]');
}

if (document.querySelectorAll('[data-modal-open-onload]')[0]) {
    onloadModal = document.querySelectorAll('[data-modal-open-onload]')[0];
    core.addClass(onloadModal, 'visuallyhidden');
    onloadModalUrl = onloadModal.getAttribute('data-modal-open-onload');
    core.modal[onloadModalUrl].toggleModal();
}


/*
@class Panel

@author
  James E Baxley III
  NewSpring Church

@version 0.1

@note
  Handles interactions of panels based on data- parameters
 */

Panel = (function () {
    function Panel(data1, attr) {
        var params;
        this.data = data1;
        this.bindEvents = bind(this.bindEvents, this);
        this.hidePanels = bind(this.hidePanels, this);
        this.hidePanel = bind(this.hidePanel, this);
        this.showPanel = bind(this.showPanel, this);
        this.loadPanel = bind(this.loadPanel, this);
        this.ajaxPanel = bind(this.ajaxPanel, this);
        this.bindClick = bind(this.bindClick, this);
        this.findTriggers = bind(this.findTriggers, this);
        this.findPanels = bind(this.findPanels, this);
        params = this.data.attributes[attr].value.split(',');
        params = params.map(function (param) {
            return param.trim();
        });
        this._properties = {
            attr: attr,
            _id: params[0],
            target: this.data,
            panels: {},
            triggers: {}
        };
        this.findPanels();
        this.findTriggers();
        if (typeof EventEmitter !== "undefined" && EventEmitter !== null) {
            this.events = new EventEmitter();
        }
        this.bindEvents();
    }

    Panel.prototype.findPanels = function () {
        var id, j, len, panel, panels, results1;
        panels = document.querySelectorAll('[data-panel]');
        results1 = [];
        for (j = 0, len = panels.length; j < len; j++) {
            panel = panels[j];
            if (panel.dataset.panel.split(',')[0] === this._properties._id) {
                id = panel.dataset.panel.split(',')[1].trim();
                results1.push(this._properties.panels[id] = panel);
            } else {
                results1.push(void 0);
            }
        }
        return results1;
    };

    Panel.prototype.findTriggers = function () {
        var _id, e, force, j, len, params, results1, trigger, triggerId, triggers;
        triggers = document.querySelectorAll('[data-panel-show]');
        results1 = [];
        for (j = 0, len = triggers.length; j < len; j++) {
            trigger = triggers[j];
            _id = trigger.dataset.panelShow.split(',')[0].trim();
            triggerId = trigger.dataset.panelShow.split(',')[2].trim();
            if (_id === this._properties._id) {
                params = trigger.dataset.panelShow.split(',');
                if (params[3]) {
                    force = (function () {
                        try {
                            return JSON.parse(params[3]);
                        } catch (_error) {
                            e = _error;
                            return false;
                        }
                    })();
                }
                if (this._properties.triggers[triggerId] === undefined || force) {
                    this._properties.triggers[triggerId] = trigger;
                    results1.push(this.bindClick(trigger));
                } else {
                    results1.push(void 0);
                }
            } else {
                results1.push(void 0);
            }
        }
        return results1;
    };

    Panel.prototype.bindClick = function (trigger) {
        return trigger.onclick = (function (_this) {
            return function (e) {
                var force, params, url;
                e.preventDefault();
                params = trigger.dataset.panelShow.split(',');
                url = params[1].trim();
                if (params[3] != null) {
                    force = (function () {
                        try {
                            return JSON.parse(params[3]);
                        } catch (_error) {
                            e = _error;
                            return false;
                        }
                    })();
                }
                return _this.loadPanel(url, force);
            };
        })(this);
    };

    Panel.prototype.ajaxPanel = function (panel) {
        var ajax;
        ajax = new XMLHttpRequest();
        ajax.onreadystatechange = (function (_this) {
            return function () {
                var content;
                if (ajax.readyState !== 4 || ajax.status !== 200) {
                    return;
                }
                content = ajax.response.body.querySelectorAll('[data-panel]')[0];
                content.style.display = "none";
                _this._properties.target.appendChild(content);
                return _this.events.emit('loaded', content);
            };
        })(this);
        ajax.open("GET", panel, true);
        ajax.responseType = 'document';
        return ajax.send();
    };

    Panel.prototype.loadPanel = function (panel, force) {
        var compiledTemplate, content, existingPanel, j, len, panels;
        if (force === true) {
            this._properties.force = true;
            this.ajaxPanel(panel, force);
            if (core['panel'][this._properties._id]._properties.panels[panel] != null) {
                this._properties.panels[panel].parentNode.removeChild(this._properties.panels[panel]);
            }
            return false;
        }
        panel = panel.trim();
        if (core['panel'][this._properties._id]._properties.panels[panel] !== undefined) {
            this.hidePanels();
            return this.showPanel(core['panel'][this._properties._id]._properties.panels[panel]);
        } else {
            panels = document.querySelectorAll('[data-panel]');
            for (j = 0, len = panels.length; j < len; j++) {
                existingPanel = panels[j];
                if (existingPanel.dataset.panel.split(',')[1] === panel) {
                    this.hidePanels();
                    this.showPanel(existingPanel);
                } else {
                    compiledTemplate = Handlebars.getTemplate(panel);
                    if (typeof compiledTemplate === 'function') {
                        content = compiledTemplate();
                        this.events.emit('loaded', content);
                    } else {
                        this.ajaxPanel(panel);
                        return false;
                    }
                }
            }
        }
    };

    Panel.prototype.showPanel = function (panel) {
        var currentTrigger, j, len, panelTrigger, results1;
        panel.style.display = "block";
        core.addClass(panel, "panel--active");
        panelTrigger = document.querySelectorAll("[data-panel-show*=\"" + panel.dataset.panel + "\"]");
        results1 = [];
        for (j = 0, len = panelTrigger.length; j < len; j++) {
            currentTrigger = panelTrigger[j];
            results1.push(core.addClass(currentTrigger, 'panel--active--link'));
        }
        return results1;
    };

    Panel.prototype.hidePanel = function (panel) {
        var j, len, previousActivePanels, previousPanel;
        if (document.getElementsByClassName("panel--active--link")) {
            previousActivePanels = document.getElementsByClassName("panel--active--link");
            for (j = 0, len = previousActivePanels.length; j < len; j++) {
                previousPanel = previousActivePanels[j];
                core.removeClass(previousPanel, "panel--active--link");
            }
        }
        panel.style.display = "none";
        core.removeClass(panel, "panel--active");
        return this;
    };

    Panel.prototype.hidePanels = function () {
        var j, len, panel, ref;
        ref = core.flattenObject(core['panel'][this._properties._id]._properties.panels);
        for (j = 0, len = ref.length; j < len; j++) {
            panel = ref[j];
            this.hidePanel(panel);
        }
        return this;
    };

    Panel.prototype.bindEvents = function () {
        this.events.on('loaded', (function (_this) {
            return function (content) {
                var j, len, panel, ref;
                if (_this._properties.force) {
                    ref = _this._properties.panels;
                    for (j = 0, len = ref.length; j < len; j++) {
                        panel = ref[j];
                        panel.parentNode.removeChild(panel);
                    }
                }
                core.updateModels(content, _this._properties.force);
                _this.findTriggers(_this._properties.force);
                _this.findPanels();
                _this.hidePanels();
                return _this.showPanel(content);
            };
        })(this));
        return this;
    };

    return Panel;

})();

if (typeof core !== "undefined" && core !== null) {
    core.addPlugin('Panel', Panel, '[data-panel-group]');
}


/*
@class Share

@author
  Rich Dubay
  NewSpring Church

@version 0.1

@note
  social share highlighted text
 */

Share = (function () {
    function Share(data1, attr) {
        var e, hashtags, json, meta, params, ref, ref1, ref2;
        this.data = data1;
        this.bindClick = bind(this.bindClick, this);
        this.email = bind(this.email, this);
        this.tweet = bind(this.tweet, this);
        this.share = bind(this.share, this);
        this.showMenu = bind(this.showMenu, this);
        this.watch = bind(this.watch, this);
        this.md = bind(this.md, this);
        this.dmd = bind(this.dmd, this);
        this.bindWatch = bind(this.bindWatch, this);
        if (this.data instanceof jQuery) {
            this.data = this.data.get(0);
        }
        params = this.data.attributes[attr].value.split(/[,](?=[^\]]*?(?:\[))(?=[^\}]*?(?:\{))/g);
        params = params.map(function (param) {
            return param.trim();
        });
        if (params.length > 3) {
            meta = params.splice(0, 2);
            json = params.join(',');
            params = meta.concat(json);
        }
        hashtags = (function () {
            try {
                return JSON.parse(params[1]).hashtags;
            } catch (_error) {
                e = _error;
                return {};
            }
        })();
        this._properties = {
            target: this.data,
            _id: params[0],
            attr: attr,
            text: null,
            handle: (ref = document.querySelectorAll('[name="twitter:creator"]')[0].content.replace('@', '')) != null ? ref : "newspring",
            url: (ref1 = document.querySelectorAll('[property="short_url"]')[0].content) != null ? ref1 : "http://newspring.cc",
            longUrl: window.location.href,
            hashtags: hashtags != null ? hashtags : false,
            subject: (ref2 = document.getElementsByTagName('title')[0].innerText) != null ? ref2 : "Ask Next Steps About This Subject Line"
        };
        if (typeof EventEmitter !== "undefined" && EventEmitter !== null) {
            this.events = new EventEmitter();
        }
        this.showMenu();
        this.bindWatch().bindClick();
    }

    Share.prototype.bindWatch = function () {
        this._properties.target.onmousedown = this.md;
        document.onmousedown = this.dmd;
        this._properties.target.onmouseup = this.watch;
        return this;
    };

    Share.prototype.dmd = function (event) {
        var el;
        this._properties.dmdy = event.pageY;
        if (this._properties.dmdy !== this._properties.mdy && event.target.parentNode.dataset.shareButton === void 0) {
            el = document.getElementById("share");
            return core.removeClass(el, "share-menu-active");
        }
    };

    Share.prototype.md = function (event) {
        this._properties.mdy = event.pageY;
        return this._properties.mdx = event.pageX;
    };

    Share.prototype.watch = function (event) {
        var boundary, el, left, range, rec, rect, selection, style, text, top, y;
        selection = document.getSelection();
        text = selection.toString();
        range = selection.getRangeAt(0).cloneRange();
        boundary = range.getBoundingClientRect();
        if (range.getClientRects) {
            range.collapse(true);
            rec = range.getClientRects()[0];
            y = rec.top;
            top = document.body.scrollTop + y;
        }
        rect = range.getClientRects()[0];
        el = document.getElementById("share");
        if (text !== "") {
            core.addClass(el, "share-menu-active");
            this._properties.text = text;
            if (event.target.parentNode.dataset.shareButton === void 0) {
                if ((this._properties.mdy !== event.pageY && this._properties.dmdy !== event.pageY) || (this._properties.mdx !== event.pageX)) {
                    top = top - el.offsetHeight - 10;
                    el.setAttribute('style', 'top:' + top + 'px;');
                    style = el.getAttribute('style');
                    left = ((rect.left + boundary.right) / 2) - (el.offsetWidth / 2);
                    if (left < 0) {
                        left = 0;
                    }
                    style = style + "left:" + left + 'px;';
                    return el.setAttribute('style', style);
                } else {
                    return core.removeClass(el, "share-menu-active");
                }
            }
        } else {
            return core.removeClass(el, "share-menu-active");
        }
    };

    Share.prototype.showMenu = function () {
        var compiledTemplate, temp, template;
        template = 'share';
        compiledTemplate = Handlebars.getTemplate(template);
        if (typeof compiledTemplate === 'function') {
            temp = document.createElement('div');
            temp.innerHTML = compiledTemplate();
            return document.body.appendChild(temp);
        }
    };

    Share.prototype.share = function (event) {
        var hashtag, hashtagCount, j, len, ref, shareData, shareHandle, shareHashtagList, shareLongUrl, shareString, shareText, shareUrl;
        event.preventDefault();
        shareText = this._properties.text;
        shareUrl = encodeURIComponent("http:" + this._properties.url.slice(this._properties.url.indexOf('//')));
        shareLongUrl = encodeURIComponent("http:" + this._properties.longUrl.slice(this._properties.longUrl.indexOf('//')));
        shareHandle = "";
        if (this._properties.handle) {
            shareHandle = "via @" + this._properties.handle;
        }
        shareHashtagList = "";
        hashtagCount = 0;
        if (this._properties.hashtags) {
            ref = this._properties.hashtags;
            for (j = 0, len = ref.length; j < len; j++) {
                hashtag = ref[j];
                shareHashtagList += hashtag + ', ';
                hashtagCount++;
            }
            shareHashtagList = shareHashtagList.slice(0, shareHashtagList.length - 2);
        }
        shareString = "";
        if (shareUrl.length > 0) {
            shareString += shareUrl + " ";
        }
        if (shareHandle.length > 0) {
            shareString += shareHandle + " ";
        }
        if (shareHashtagList.length > 0) {
            shareString += shareHashtagList;
        }
        shareData = {
            shareHandle: shareHandle,
            shareString: shareString,
            shareText: '\"' + shareText + '\"',
            shareUrl: shareUrl,
            shareLongUrl: shareLongUrl,
            shareHashtagList: shareHashtagList.replace(' ', ''),
            hashtagCount: hashtagCount,
            emailSubject: encodeURIComponent(this._properties.subject.trim())
        };
        if (event.target.parentNode.id === "twitter-share-button") {
            return this.tweet(shareData);
        } else if (event.target.parentNode.id === "email-share-button") {
            return this.email(shareData);
        } else {
            return console.log('facebook can go here');
        }
    };

    Share.prototype.tweet = function (tweet) {
        var el, twitterShareUrl, whatIsLeftOver;
        whatIsLeftOver = 140 - tweet.shareString.length;
        if (tweet.shareText.length > whatIsLeftOver) {
            whatIsLeftOver -= tweet.hashtagCount + 6;
            tweet.shareText = tweet.shareText.slice(0, whatIsLeftOver);
            tweet.shareText += "...\"";
        }
        twitterShareUrl = "https://twitter.com/intent/tweet?";
        twitterShareUrl += "text=" + encodeURIComponent(tweet.shareText);
        twitterShareUrl += "&url=" + tweet.shareUrl;
        if (this._properties.handle) {
            twitterShareUrl += "&via=" + this._properties.handle;
        }
        if (this._properties.hashtags) {
            twitterShareUrl += "&hashtags=" + tweet.shareHashtagList;
        }
        el = document.getElementById("share");
        core.removeClass(el, "share-menu-active");
        document.getSelection().removeAllRanges();
        return window.open(twitterShareUrl, '_blank', 'location=yes,height=420,width=550');
    };

    Share.prototype.email = function (shareData) {
        var el, emailBody, emailSubject, mailtoLink, newline;
        newline = "\r\n";
        emailSubject = shareData.emailSubject;
        emailBody = "I found this on " + shareData.shareLongUrl + "<br /><br />" + encodeURIComponent(shareData.shareText);
        mailtoLink = "mailto:?subject=" + emailSubject + "&body=" + emailBody;
        el = document.getElementById("share");
        core.removeClass(el, "share-menu-active");
        document.getSelection().removeAllRanges();
        return window.location.href = mailtoLink;
    };

    Share.prototype.bindClick = function () {
        var j, len, results1, trigger, triggers;
        triggers = document.querySelectorAll('[data-share-button]');
        results1 = [];
        for (j = 0, len = triggers.length; j < len; j++) {
            trigger = triggers[j];
            this._properties.trigger = trigger;
            results1.push(trigger.addEventListener('click', this.share, false));
        }
        return results1;
    };

    return Share;

})();

if (typeof core !== "undefined" && core !== null) {
    core.addPlugin("Share", Share, '[data-share]');
}


/*
@class Slider

@author
  James E Baxley III
  NewSpring Church

@version 0.1

@note
  Handles interactions of accordions based on data- parameters

@dependencies
  slick.js
 */

Slider = (function () {
    function Slider(data1, attr) {
        var e, json, meta, params;
        this.data = data1;
        this.enableSlider = bind(this.enableSlider, this);
        this.configureSettings = bind(this.configureSettings, this);
        this.getBreakpoints = bind(this.getBreakpoints, this);
        params = this.data.attributes[attr].value.split(',');
        params = params.map(function (param) {
            return param.trim();
        });
        if (params.length > 3) {
            meta = params.splice(0, 2);
            json = params.join(',');
            params = meta.concat(json);
        }
        this._properties = {
            _id: params[0],
            target: this.data,
            start: params[1] - 1,
            settings: (function () {
                try {
                    return JSON.parse(params[2]);
                } catch (_error) {
                    e = _error;
                    return {};
                }
            })()
        };
        this.configureSettings();
    }

    Slider.prototype.getBreakpoints = function () {
        var responsive;
        responsive = [{
            breakpoint: 1600,
            settings: {
                centerMode: true,
                slidesToShow: 1
            }
        },
        {
            breakpoint: 1280,
            settings: {
                centerMode: true,
                slidesToShow: 1
            }
        },
        {
            breakpoint: 960,
            settings: {
                centerMode: true,
                slidesToShow: 1
            }
        },
        {
            breakpoint: 480,
            settings: {
                centerMode: true,
                slidesToShow: 1
            }
        }];
        return responsive;
    };

    Slider.prototype.configureSettings = function () {
        var settings;
        settings = this._properties.settings;
        if (settings.showTitles) {
            settings.customPaging = function (slick, index) {
                var paging;
                paging = $(slick.$slides.get(index)).find('a').attr('title') || '';
                return '<a class="slider__nav--title" >' + paging + '</a>';
            };
        }
        if (settings.responsive) {
            settings = {
                centerMode: true,
                centerPadding: "60px",
                slidesToShow: 3,
                responsive: [{
                    breakpoint: 768,
                    settings: {
                        arrows: true,
                        centerMode: true,
                        centerPadding: "20px",
                        slidesToShow: 1
                    }
                },
                {
                    breakpoint: 480,
                    settings: {
                        arrows: true,
                        centerMode: true,
                        centerPadding: "5px",
                        slidesToShow: 1
                    }
                }]
            };
        }
        return this.enableSlider(settings);
    };

    Slider.prototype.enableSlider = function (settings) {
        return document.addEventListener('DOMContentLoaded', (function (_this) {
            return function () {
                return $(_this._properties.target).slick(settings).slickGoTo(_this._properties.start);
            };
        })(this));
    };

    return Slider;

})();

if (jQuery && (typeof core !== "undefined" && core !== null)) {
    core.addPlugin('Slider', Slider, '[data-slider]');
}


/*

@class NewSpringPlayer

@author
	James E Baxley III
	NewSpring Church

@version 0.1
 */

Player = (function () {

/*
  	Constructor function runs when object gets initialized
  
  	@param {Element} Element to be used for creating video and image fallback
   */

    function Player(data1, attr) {
        var e, json, meta, params;
        this.data = data1;
        this.reportEvent = bind(this.reportEvent, this);
        this.setUpOO = bind(this.setUpOO, this);
        this.setUpVideo = bind(this.setUpVideo, this);
        this.loadScripts = bind(this.loadScripts, this);
        this.loadModal = bind(this.loadModal, this);
        if (this.data instanceof jQuery) {
            this.data = this.data.get(0);
        }
        params = this.data.attributes[attr].value.split(',');
        params = params.map(function (param) {
            return param.trim();
        });
        if (params.length > 3) {
            meta = params.splice(0, 2);
            json = params.join(',');
            params = meta.concat(json);
        }
        this._properties = {
            _id: params[0],
            video: {
                element: this.data,
                klass: this.data.className,
                code: params[1]
            },
            params: (function () {
                try {
                    return JSON.parse(params[2]);
                } catch (_error) {
                    e = _error;
                    return {};
                }
            })(),
            scriptKeys: {
                ooyala: "//player.ooyala.com/v3/ZmJmNTVlNDk1NjcwYTVkMzAzODkyMjg0?tweaks=android-enable-hls"
            }
        };
        this._properties.params.template = this._properties.params.template || 'videoPlayer';
        this._properties.params.type = this._properties.params.type || 'ooyala';
        this._properties.params.playerId = this._properties.params.playerId || 'player--ooyala';
        this._properties.params.autoPlay = this._properties.params.autoPlay || false;
        this.loadScripts().loadModal().setUpVideo();
    }

    Player.prototype.loadModal = function () {
        var tmpl;
        Modal = core['plugins']['Modal'];
        if (Modal != null) {
            if (core.modal != null) {
                if (core.modal[this._properties.params.template] === void 0) {
                    tmpl = this._properties.params.template;
                    core.modal[tmpl] = new Modal.model(tmpl, 'data-modal-open', "preload");
                }
            } else {
                core.modal = {};
                tmpl = this._properties.params.template;
                core.modal[tmpl] = new Modal.model(tmpl, 'data-modal-open', "preload");
            }
        }
        return this;
    };


/*
  
  	@function loadScripts()
  
  	@note
  		loads needed scripts on the page for embeded video
  
  	@chainable
   */

    Player.prototype.loadScripts = function () {
        var script, scripts, scrpt;
        script = document.createElement("script");
        if (this._properties.scriptKeys[this._properties.params.type] != null) {
            script.setAttribute("src", this._properties.scriptKeys[this._properties.params.type]);
        } else {
            le.log("no script key found for " + this._properties.video.type);
            false;
        }
        scripts = core.flatten(document.getElementsByTagName("script"));
        scrpt = scripts.filter((function (_this) {
            return function (attr) {
                if ((attr.attributes["src"] != null) && (attr.attributes["src"].value != null)) {
                    return attr.attributes["src"].value === _this._properties.scriptKeys[_this._properties.params.type];
                }
            };
        })(this));
        if (!(scrpt.length > 0)) {
            document.head.appendChild(script);
        }
        return this;
    };


/*
  
  	@function setUpVideo()
  
  	@note
  		Router function for video setup based on type
  
  	@todo
  		Write way to dynamically call function based on @_properties.video.type
  		DO NOT USE EVAL
  
  	@chainable
   */

    Player.prototype.setUpVideo = function () {
        if (this._properties.params.type === "ooyala") {
            if (!this._properties.params.autoPlay) {
                this._properties.video.element.addEventListener("click", this.setUpOO, false);
            } else {
                this.setUpOO();
                this._properties.video.element.addEventListener("click", this.setUpOO, false);
            }
        }
        return this;
    };


/*
  
  	@function setUpOO()
  
  	@note
  		Setting up ooyala videos
  
  	@todo
  		Explore OO API for more powerful scripting
  
  	@chainable
   */

    Player.prototype.setUpOO = function () {
        if (typeof OO === "undefined" || OO === null) {

/*
      
      			@todo
      			Set up better error handling.
      			Would like to have it try to load script again
      			If countinues to fail then load error and send to GA
       */
            callback = (function (_this) {
                return function () {
                    return _this.setUpOO();
                };
            })(this);
            setTimeout(callback, 250);
        } else {
            OO.ready((function (_this) {
                return function () {
                    var destroy, fullscreen, listen;
                    core.modal[_this._properties.params.template].toggleModal();
                    _this._properties.video.player = OO.Player.create(_this._properties.params.playerId, _this._properties.video.code, {
                        autoplay: true,
                        onCreate: function (player) {
                            return _this._properties.messages = player.mb;
                        }
                    });
                    destroy = function () {
                        _this.reportEvent("destroyed");
                        return _this._properties.video.player.destroy(_this._properties.params.playerId);
                    };
                    listen = function (event) {
                        if (event.keyCode === 27 || core.isElement(event)) {
                            destroy();
                            if (event.keyCode === 27) {
                                core.modal[_this._properties.params.template].toggleModal();
                            }
                            return document.removeEventListener("keyup", listen, false);
                        } else if (event.keyCode === 32) {
                            if (_this._properties.video.player.state === "paused") {
                                return _this._properties.video.player.play();
                            } else {
                                return _this._properties.video.player.pause();
                            }
                        }
                    };
                    document.addEventListener("keyup", listen, false);
                    core.modal[_this._properties.params.template].events.on('close', listen);

/*
          
          				Playing events
           */
                    _this._properties.messages.subscribe(OO.EVENTS.PLAYBACK_READY, "Video", function (eventName) {
                        return _this.reportEvent(eventName);
                    });
                    _this._properties.messages.subscribe(OO.EVENTS.PLAYED, "Video", function (eventName) {
                        destroy();
                        core.modal[_this._properties.params.template].toggleModal();
                        return _this.reportEvent(eventName);
                    });

/*
          
          				Error Events
           */
                    _this._properties.messages.subscribe(OO.EVENTS.PLAY_FAILED, "Video", function (eventName) {
                        return _this.reportEvent(eventName);
                    });
                    _this._properties.messages.subscribe(OO.EVENTS.BUFFERED, "Video", function (eventName) {
                        return _this.reportEvent(eventName);
                    });

/*
          
          				UI Events
           */
                    fullscreen = false;
                    return _this._properties.messages.subscribe(OO.EVENTS.FULLSCREEN_CHANGED, "Video", function (eventName) {
                        fullscreen = !fullscreen;
                        if (fullscreen) {
                            eventName = "Fullscreen";
                            return _this.reportEvent(eventName);
                        }
                    });
                };
            })(this));
        }
        return this;
    };


/*
  
  	@function reportEvent()
  
  	@param {String} Event name for posting to GA
  
  	@chainable
   */

    Player.prototype.reportEvent = function (event) {
        if (typeof ga !== "undefined" && ga !== null) {
            ga("send", "event", "video", event, {
                'page': window.location.pathname
            });
        }
        return this;
    };

    return Player;

})();

if (typeof core !== "undefined" && core !== null) {
    core.addPlugin('Player', Player, '[data-video]');
}


/*

  This file houses the coffeescript tree of files
  We run a js and a coffee tree so that plugins can import js files
  and compilation still works. Otherwise coffeescript can't compile js in
  a coffee file
 */